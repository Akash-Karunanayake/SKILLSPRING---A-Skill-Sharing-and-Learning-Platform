This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
src/main/java/com/socialapp/Zircuit/config/CacheConfig.java
src/main/java/com/socialapp/Zircuit/config/CorsConfig.java
src/main/java/com/socialapp/Zircuit/config/DataInitializer.java
src/main/java/com/socialapp/Zircuit/config/PasswordConfig.java
src/main/java/com/socialapp/Zircuit/config/ResponseHandler.java
src/main/java/com/socialapp/Zircuit/config/SecurityConfig.java
src/main/java/com/socialapp/Zircuit/config/WebSocketConfig.java
src/main/java/com/socialapp/Zircuit/controller/AuthController.java
src/main/java/com/socialapp/Zircuit/controller/FollowController.java
src/main/java/com/socialapp/Zircuit/controller/MessageController.java
src/main/java/com/socialapp/Zircuit/controller/NotificationController.java
src/main/java/com/socialapp/Zircuit/controller/ResourceController.java
src/main/java/com/socialapp/Zircuit/controller/UserController.java
src/main/java/com/socialapp/Zircuit/controller/WebSocketMessageHandler.java
src/main/java/com/socialapp/Zircuit/exception/AppException.java
src/main/java/com/socialapp/Zircuit/exception/BadRequestException.java
src/main/java/com/socialapp/Zircuit/exception/ErrorDetails.java
src/main/java/com/socialapp/Zircuit/exception/GlobalExceptionHandler.java
src/main/java/com/socialapp/Zircuit/exception/ResourceNotFoundException.java
src/main/java/com/socialapp/Zircuit/exception/UnauthorizedException.java
src/main/java/com/socialapp/Zircuit/exception/ValidationErrorDetails.java
src/main/java/com/socialapp/Zircuit/model/dto/request/LoginRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/request/MessageRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/request/MessageSettingsRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/request/ProfileUpdateRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/request/RegisterRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/request/SettingsUpdateRequest.java
src/main/java/com/socialapp/Zircuit/model/dto/response/AuthResponse.java
src/main/java/com/socialapp/Zircuit/model/dto/response/ConversationResponse.java
src/main/java/com/socialapp/Zircuit/model/dto/response/MessageResponse.java
src/main/java/com/socialapp/Zircuit/model/dto/response/NotificationResponse.java
src/main/java/com/socialapp/Zircuit/model/dto/response/ProfileResponse.java
src/main/java/com/socialapp/Zircuit/model/dto/response/UserSummaryResponse.java
src/main/java/com/socialapp/Zircuit/model/entity/Follow.java
src/main/java/com/socialapp/Zircuit/model/entity/Message.java
src/main/java/com/socialapp/Zircuit/model/entity/Notification.java
src/main/java/com/socialapp/Zircuit/model/entity/User.java
src/main/java/com/socialapp/Zircuit/model/entity/UserAuth.java
src/main/java/com/socialapp/Zircuit/model/entity/UserSettings.java
src/main/java/com/socialapp/Zircuit/model/entity/VerificationToken.java
src/main/java/com/socialapp/Zircuit/model/enums/AuthProvider.java
src/main/java/com/socialapp/Zircuit/model/enums/MessagePermission.java
src/main/java/com/socialapp/Zircuit/model/enums/NotificationType.java
src/main/java/com/socialapp/Zircuit/repository/FollowRepository.java
src/main/java/com/socialapp/Zircuit/repository/MessageRepository.java
src/main/java/com/socialapp/Zircuit/repository/NotificationRepository.java
src/main/java/com/socialapp/Zircuit/repository/UserAuthRepository.java
src/main/java/com/socialapp/Zircuit/repository/UserRepository.java
src/main/java/com/socialapp/Zircuit/repository/UserSettingsRepository.java
src/main/java/com/socialapp/Zircuit/repository/VerificationTokenRepository.java
src/main/java/com/socialapp/Zircuit/security/CustomUserDetailsService.java
src/main/java/com/socialapp/Zircuit/security/JwtAuthenticationEntryPoint.java
src/main/java/com/socialapp/Zircuit/security/JwtAuthenticationFilter.java
src/main/java/com/socialapp/Zircuit/security/JwtTokenProvider.java
src/main/java/com/socialapp/Zircuit/security/OAuth2AuthenticationSuccessHandler.java
src/main/java/com/socialapp/Zircuit/security/UserPrincipal.java
src/main/java/com/socialapp/Zircuit/service/AuthService.java
src/main/java/com/socialapp/Zircuit/service/EmailService.java
src/main/java/com/socialapp/Zircuit/service/FileStorageService.java
src/main/java/com/socialapp/Zircuit/service/FollowService.java
src/main/java/com/socialapp/Zircuit/service/MessageService.java
src/main/java/com/socialapp/Zircuit/service/NotificationService.java
src/main/java/com/socialapp/Zircuit/service/TokenService.java
src/main/java/com/socialapp/Zircuit/service/UserService.java
src/main/java/com/socialapp/Zircuit/util/SecurityUtils.java
src/main/java/com/socialapp/Zircuit/util/ValidationUtils.java
src/main/java/com/socialapp/Zircuit/ZircuitApplication.java
src/main/resources/application.properties
src/main/resources/META-INF/additional-spring-configuration-metadata.json
src/test/java/com/socialapp/Zircuit/ZircuitApplicationTests.java

================================================================
Files
================================================================

================
File: src/main/java/com/socialapp/Zircuit/config/PasswordConfig.java
================
package com.socialapp.Zircuit.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

@Configuration
public class PasswordConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/AppException.java
================
package com.socialapp.Zircuit.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
public class AppException extends RuntimeException {
    public AppException(String message) {
        super(message);
    }
    
    public AppException(String message, Throwable cause) {
        super(message, cause);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/BadRequestException.java
================
package com.socialapp.Zircuit.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.BAD_REQUEST)
public class BadRequestException extends RuntimeException {
    public BadRequestException(String message) {
        super(message);
    }
    
    public BadRequestException(String message, Throwable cause) {
        super(message, cause);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/ErrorDetails.java
================
package com.socialapp.Zircuit.exception;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ErrorDetails {
    private Date timestamp;
    private String message;
    private String details;
    private int status;
}

================
File: src/main/java/com/socialapp/Zircuit/exception/GlobalExceptionHandler.java
================
package com.socialapp.Zircuit.exception;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.HttpStatusCode;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

import java.util.Date;
import java.util.HashMap;
import java.util.Map;

@ControllerAdvice
@Slf4j
public class GlobalExceptionHandler extends ResponseEntityExceptionHandler{
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<?> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                new Date(),
                ex.getMessage(),
                request.getDescription(false),
                HttpStatus.NOT_FOUND.value());
        
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<?> handleBadRequestException(BadRequestException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                new Date(),
                ex.getMessage(),
                request.getDescription(false),
                HttpStatus.BAD_REQUEST.value());
        
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<?> handleUnauthorizedException(UnauthorizedException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                new Date(),
                ex.getMessage(),
                request.getDescription(false),
                HttpStatus.UNAUTHORIZED.value());
        
        return new ResponseEntity<>(errorDetails, HttpStatus.UNAUTHORIZED);
    }

    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<?> handleAccessDeniedException(AccessDeniedException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                new Date(),
                "You don't have permission to access this resource",
                request.getDescription(false),
                HttpStatus.FORBIDDEN.value());
        
        return new ResponseEntity<>(errorDetails, HttpStatus.FORBIDDEN);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGlobalException(Exception ex, WebRequest request) {
        log.error("Unhandled exception", ex);
        ErrorDetails errorDetails = new ErrorDetails(
                new Date(),
                ex.getMessage(),
                request.getDescription(false),
                HttpStatus.INTERNAL_SERVER_ERROR.value());
        
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }
    
    @Override
    protected ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex,
                                                                  HttpHeaders headers,
                                                                  HttpStatusCode status,
                                                                  WebRequest request) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        ValidationErrorDetails errorDetails = new ValidationErrorDetails(
                new Date(),
                "Validation Failed",
                request.getDescription(false),
                HttpStatus.BAD_REQUEST.value(),
                errors);
        
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/ResourceNotFoundException.java
================
package com.socialapp.Zircuit.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {
    private final String resourceName;
    private final String fieldName;
    private final Object fieldValue;
    
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(String.format("%s not found with %s : '%s'", resourceName, fieldName, fieldValue));
        this.resourceName = resourceName;
        this.fieldName = fieldName;
        this.fieldValue = fieldValue;
    }
    
    public String getResourceName() {
        return resourceName;
    }
    
    public String getFieldName() {
        return fieldName;
    }
    
    public Object getFieldValue() {
        return fieldValue;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/UnauthorizedException.java
================
package com.socialapp.Zircuit.exception;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

@ResponseStatus(HttpStatus.UNAUTHORIZED)
public class UnauthorizedException extends RuntimeException {
    public UnauthorizedException(String message) {
        super(message);
    }
    
    public UnauthorizedException(String message, Throwable cause) {
        super(message, cause);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/exception/ValidationErrorDetails.java
================
package com.socialapp.Zircuit.exception;
import lombok.Getter;
import lombok.Setter;

import java.util.Date;
import java.util.Map;

@Getter
@Setter
public class ValidationErrorDetails extends ErrorDetails {
    private Map<String, String> errors;
    
    public ValidationErrorDetails(Date timestamp, String message, String details, int status, Map<String, String> errors) {
        super(timestamp, message, details, status);
        this.errors = errors;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/LoginRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest {
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "Password is required")
    private String password;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/MessageRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Size;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MessageRequest {
    @NotNull(message = "Receiver ID is required")
    private String receiverId;
    
    @NotBlank(message = "Content is required")
    @Size(max = 1000, message = "Message content cannot exceed 1000 characters")
    private String content;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/MessageSettingsRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import com.socialapp.Zircuit.model.enums.MessagePermission;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.NotNull;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MessageSettingsRequest {
    @NotNull(message = "Message permission setting is required")
    private MessagePermission allowMessagesFrom;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/ProfileUpdateRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.validator.constraints.URL;

import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProfileUpdateRequest {
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9_]*$", message = "Username can only contain letters, numbers, and underscores")
    private String username;
    
    @Size(max = 100, message = "Full name cannot exceed 100 characters")
    private String fullName;
    
    @Size(max = 500, message = "Bio cannot exceed 500 characters")
    private String bio;
    
    @URL(message = "Website URL must be valid")
    @Size(max = 255, message = "Website URL cannot exceed 255 characters")
    private String websiteUrl;
    
    @Size(max = 100, message = "Location cannot exceed 100 characters")
    private String location;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/RegisterRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RegisterRequest {
    @NotBlank(message = "Username is required")
    @Size(min = 3, max = 50, message = "Username must be between 3 and 50 characters")
    @Pattern(regexp = "^[a-zA-Z0-9_]*$", message = "Username can only contain letters, numbers, and underscores")
    private String username;
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email should be valid")
    private String email;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    private String password;
    
    @NotBlank(message = "Full name is required")
    @Size(max = 100, message = "Full name cannot exceed 100 characters")
    private String fullName;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/request/SettingsUpdateRequest.java
================
package com.socialapp.Zircuit.model.dto.request;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.validation.constraints.Email;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class SettingsUpdateRequest {
    private Boolean isPublic;
    
    @Email(message = "Email should be valid")
    private String email;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/AuthResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuthResponse {
    private String token;
    private String refreshToken;
    private UserSummaryResponse user;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/ConversationResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ConversationResponse {
    private UserSummaryResponse user;
    private MessageResponse latestMessage;
    private long unreadCount;
    private LocalDateTime lastActivity;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/MessageResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class MessageResponse {
    private String id;
    private String senderId;
    private String receiverId;
    private String content;
    private boolean isRead;
    private LocalDateTime sentAt;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/NotificationResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import com.socialapp.Zircuit.model.enums.NotificationType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class NotificationResponse {
    private String id;
    private NotificationType type;
    private String content;
    private UserSummaryResponse actor;
    private String referenceId;
    private boolean isRead;
    private LocalDateTime createdAt;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/ProfileResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;


@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ProfileResponse {
    private String id;
    private String username;
    private String email;
    private String fullName;
    private String bio;
    private String avatarUrl;
    private String websiteUrl;
    private String location;
    private boolean isPublic;
    private boolean isVerified;
    private long followerCount;
    private long followingCount;
    private boolean isFollowing;
}

================
File: src/main/java/com/socialapp/Zircuit/model/dto/response/UserSummaryResponse.java
================
package com.socialapp.Zircuit.model.dto.response;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserSummaryResponse {
    private String id;
    private String username;
    private String email;
    private String fullName;
    private String avatarUrl;
    private boolean isPublic;
    private boolean isVerified;
}

================
File: src/main/java/com/socialapp/Zircuit/model/enums/AuthProvider.java
================
package com.socialapp.Zircuit.model.enums;

public enum AuthProvider {
    GOOGLE,
    FACEBOOK,
    GITHUB
}

================
File: src/main/java/com/socialapp/Zircuit/model/enums/MessagePermission.java
================
package com.socialapp.Zircuit.model.enums;

public enum MessagePermission {
    ALL,
    FOLLOWING,
    NONE
}

================
File: src/main/java/com/socialapp/Zircuit/model/enums/NotificationType.java
================
package com.socialapp.Zircuit.model.enums;

public enum NotificationType {
    FOLLOW,
    LIKE,
    COMMENT,
    MESSAGE,
    MILESTONE,
    SYSTEM
}

================
File: src/main/java/com/socialapp/Zircuit/repository/FollowRepository.java
================
package com.socialapp.Zircuit.repository;

import com.socialapp.Zircuit.model.entity.Follow;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface FollowRepository extends JpaRepository<Follow, Follow.FollowId> {
    Page<Follow> findByIdFollowerId(String followerId, Pageable pageable);
    
    Page<Follow> findByIdFollowedId(String followedId, Pageable pageable);
    
    boolean existsByIdFollowerIdAndIdFollowedId(String followerId, String followedId);
    
    @Query("SELECT COUNT(f) FROM Follow f WHERE f.id.followedId = :userId")
    long countFollowersByUserId(@Param("userId") String userId);
    
    @Query("SELECT COUNT(f) FROM Follow f WHERE f.id.followerId = :userId")
    long countFollowingByUserId(@Param("userId") String userId);
}

================
File: src/main/java/com/socialapp/Zircuit/repository/MessageRepository.java
================
package com.socialapp.Zircuit.repository;

import com.socialapp.Zircuit.model.entity.Message;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MessageRepository extends JpaRepository<Message, String>{
    @Query("SELECT m FROM Message m WHERE (m.senderId = :user1 AND m.receiverId = :user2) OR (m.senderId = :user2 AND m.receiverId = :user1) ORDER BY m.sentAt DESC")
    Page<Message> findConversation(@Param("user1") String user1, @Param("user2") String user2, Pageable pageable);
    
    @Query("SELECT m FROM Message m WHERE (m.receiverId = :userId AND m.isDeletedByReceiver = false) OR (m.senderId = :userId AND m.isDeletedBySender = false) ORDER BY m.sentAt DESC")
    Page<Message> findAllByUserId(@Param("userId") String userId, Pageable pageable);
    
    @Query("SELECT COUNT(m) FROM Message m WHERE m.receiverId = :userId AND m.isRead = false")
    long countUnreadMessages(@Param("userId") String userId);
    
    @Query(value = "SELECT DISTINCT " +
            "CASE WHEN m.sender_id = :userId THEN m.receiver_id ELSE m.sender_id END AS other_user_id, " +
            "MAX(m.sent_at) as latest_message_time " +
            "FROM messages m " +
            "WHERE (m.sender_id = :userId AND m.is_deleted_by_sender = false) " +
            "OR (m.receiver_id = :userId AND m.is_deleted_by_receiver = false) " +
            "GROUP BY other_user_id " +
            "ORDER BY latest_message_time DESC", 
            nativeQuery = true)
    List<Object[]> findConversationPartners(@Param("userId") String userId, Pageable pageable);
    
    @Query("SELECT COUNT(m) FROM Message m WHERE m.receiverId = :userId AND m.senderId = :otherUserId AND m.isRead = false")
    long countUnreadMessagesFromUser(@Param("userId") String userId, @Param("otherUserId") String otherUserId);
}

================
File: src/main/java/com/socialapp/Zircuit/repository/NotificationRepository.java
================
package com.socialapp.Zircuit.repository;
import com.socialapp.Zircuit.model.entity.Notification;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

@Repository
public interface NotificationRepository extends JpaRepository<Notification, String> {
    Page<Notification> findByUserIdOrderByCreatedAtDesc(String userId, Pageable pageable);
    
    Page<Notification> findByUserIdAndIsReadOrderByCreatedAtDesc(String userId, boolean isRead, Pageable pageable);
    
    @Query("SELECT COUNT(n) FROM Notification n WHERE n.userId = :userId AND n.isRead = false")
    long countUnreadNotifications(@Param("userId") String userId);
    
    @Modifying
    @Query("UPDATE Notification n SET n.isRead = true WHERE n.userId = :userId")
    void markAllAsRead(@Param("userId") String userId);
}

================
File: src/main/java/com/socialapp/Zircuit/repository/UserAuthRepository.java
================
package com.socialapp.Zircuit.repository;
import com.socialapp.Zircuit.model.entity.UserAuth;
import com.socialapp.Zircuit.model.enums.AuthProvider;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserAuthRepository extends JpaRepository<UserAuth, Long> {
    Optional<UserAuth> findByProviderAndProviderUserId(AuthProvider provider, String providerUserId);
    
    Optional<UserAuth> findByUserId(String userId);
    
    boolean existsByProviderAndProviderUserId(AuthProvider provider, String providerUserId);
}

================
File: src/main/java/com/socialapp/Zircuit/repository/UserRepository.java
================
package com.socialapp.Zircuit.repository;

import com.socialapp.Zircuit.model.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, String> {
    Optional<User>findByUsername(String username);
    Optional<User> findByEmail(String email);

    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
    
}

================
File: src/main/java/com/socialapp/Zircuit/repository/UserSettingsRepository.java
================
package com.socialapp.Zircuit.repository;

import com.socialapp.Zircuit.model.entity.UserSettings;
import org.springframework.stereotype.Repository;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

@Repository
public interface UserSettingsRepository extends JpaRepository<UserSettings, String> {
    
    Optional<UserSettings> findByUserId(String userId);
}

================
File: src/main/java/com/socialapp/Zircuit/repository/VerificationTokenRepository.java
================
package com.socialapp.Zircuit.repository;
import com.socialapp.Zircuit.model.entity.VerificationToken;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.Instant;
import java.util.Optional;

@Repository
public interface VerificationTokenRepository extends JpaRepository<VerificationToken, String> {
    Optional<VerificationToken> findByToken(String token);
    
    Optional<VerificationToken> findByUserIdAndTokenTypeAndUsedFalseAndExpiryDateAfter(
            String userId, 
            VerificationToken.TokenType tokenType, 
            Instant now);
    
    void deleteByUserIdAndTokenType(String userId, VerificationToken.TokenType tokenType);
}

================
File: src/main/java/com/socialapp/Zircuit/security/CustomUserDetailsService.java
================
package com.socialapp.Zircuit.security;

import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.repository.UserRepository;
import lombok.RequiredArgsConstructor;

import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    @Transactional
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(usernameOrEmail)
                .orElseGet(() -> userRepository.findByUsername(usernameOrEmail)
                        .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail)));
        
        return UserPrincipal.create(user);
    }

    @Transactional
    public UserDetails loadUserById(String id) {
        User user = userRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", id));
        
        return UserPrincipal.create(user);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/security/JwtAuthenticationEntryPoint.java
================
package com.socialapp.Zircuit.security;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Component
@RequiredArgsConstructor
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint {
    private final ObjectMapper objectMapper;

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
        
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        Map<String, Object> errorDetails = new HashMap<>();
        errorDetails.put("status", HttpStatus.UNAUTHORIZED.value());
        errorDetails.put("error", "Unauthorized");
        errorDetails.put("message", authException.getMessage() != null ? 
                authException.getMessage() : "You need to be authenticated to access this resource");
        errorDetails.put("path", request.getRequestURI());
        
        objectMapper.writeValue(response.getOutputStream(), errorDetails);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/security/JwtAuthenticationFilter.java
================
package com.socialapp.Zircuit.security;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;
import org.springframework.web.filter.OncePerRequestFilter;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
@RequiredArgsConstructor
@Slf4j
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtTokenProvider tokenProvider;
    private final CustomUserDetailsService customUserDetailsService;

    @Value("${app.jwt.header}")
    private String tokenHeader;

    @Value("${app.jwt.prefix}")
    private String tokenPrefix;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        try {
            String jwt = getJwtFromRequest(request);

            if (StringUtils.hasText(jwt) && tokenProvider.validateToken(jwt)) {
                String userId = tokenProvider.getUserIdFromToken(jwt);

                UserDetails userDetails = customUserDetailsService.loadUserById(userId);
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));

                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (Exception ex) {
            log.error("Could not set user authentication in security context", ex);
        }

        filterChain.doFilter(request, response);
    }

    private String getJwtFromRequest(HttpServletRequest request) {
        String bearerToken = request.getHeader(tokenHeader);
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(tokenPrefix)) {
            return bearerToken.substring(tokenPrefix.length());
        }
        return null;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/security/JwtTokenProvider.java
================
package com.socialapp.Zircuit.security;

import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;
import javax.crypto.SecretKey;
import java.nio.charset.StandardCharsets;
import java.util.Date;

@Component
@Slf4j
public class JwtTokenProvider {

    private static final Logger logger = LoggerFactory.getLogger(JwtTokenProvider.class);

    @Value("${app.jwt.secret}")
    private String jwtSecret;

    @Value("${app.jwt.expirationMs}")
    private long jwtExpirationInMs;

    @Value("${app.jwt.refreshExpirationMs}")
    private long refreshExpirationInMs;

    @Value("${app.verification.tokenExpirationMs}")
    private long emailVerificationExpirationInMs;
    
    @Value("${app.password-reset.tokenExpirationMs}")
    private long passwordResetExpirationInMs;

    private SecretKey secretKey;

    private final CustomUserDetailsService userDetailsService;

    public JwtTokenProvider(CustomUserDetailsService userDetailsService) {
        this.userDetailsService = userDetailsService;
    }

    @PostConstruct
    protected void init() {
        // Added null check and better error handling
        if (jwtSecret == null || jwtSecret.trim().isEmpty()) {
            throw new IllegalArgumentException("JWT secret cannot be null or empty");
        }
        try {
            secretKey = Keys.hmacShaKeyFor(jwtSecret.getBytes(StandardCharsets.UTF_8));
        } catch (Exception e) {
            logger.error("Failed to initialize JWT key", e);
            throw new RuntimeException("Could not initialize JWT secret key", e);
        }
    }

    public String generateToken(String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + jwtExpirationInMs);

        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(secretKey)
                .compact();
    }

    public String generateRefreshToken(String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + refreshExpirationInMs);

        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(secretKey)
                .compact();
    }
    
    public String generateEmailVerificationToken(String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + emailVerificationExpirationInMs);
        
        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(secretKey)
                .compact();
    }
    
    public String generatePasswordResetToken(String userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + passwordResetExpirationInMs);
        
        return Jwts.builder()
                .setSubject(userId)
                .setIssuedAt(now)
                .setExpiration(expiryDate)
                .signWith(secretKey)
                .compact();
    }

    public String getUserIdFromToken(String token) {
        Claims claims = Jwts.parserBuilder()
                .setSigningKey(secretKey)
                .build()
                .parseClaimsJws(token)
                .getBody();

        return claims.getSubject();
    }
    
    public boolean validateToken(String token) {
        try {
            Jwts.parserBuilder().setSigningKey(secretKey).build().parseClaimsJws(token);
            return true;
        } catch (SignatureException ex) {
            log.error("Invalid JWT signature");
        } catch (MalformedJwtException ex) {
            log.error("Invalid JWT token");
        } catch (ExpiredJwtException ex) {
            log.error("Expired JWT token");
        } catch (UnsupportedJwtException ex) {
            log.error("Unsupported JWT token");
        } catch (IllegalArgumentException ex) {
            log.error("JWT claims string is empty");
        }
        return false;
    }
    
    public Authentication getAuthentication(String token) {
        UserDetails userDetails = userDetailsService.loadUserById(getUserIdFromToken(token));
        return new UsernamePasswordAuthenticationToken(userDetails, "", userDetails.getAuthorities());
    }
}

================
File: src/main/java/com/socialapp/Zircuit/security/OAuth2AuthenticationSuccessHandler.java
================
package com.socialapp.Zircuit.security;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.web.authentication.SimpleUrlAuthenticationSuccessHandler;
import org.springframework.stereotype.Component;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.web.util.UriComponentsBuilder;
import java.io.IOException;
import org.springframework.context.ApplicationContext;
import org.springframework.beans.factory.annotation.Autowired;
import com.socialapp.Zircuit.service.AuthService;

@Component
public class OAuth2AuthenticationSuccessHandler extends SimpleUrlAuthenticationSuccessHandler {

    @Value("${app.frontend.url}")
    private String frontendUrl;

    private final JwtTokenProvider tokenProvider;
    private final ApplicationContext applicationContext;

    public OAuth2AuthenticationSuccessHandler(JwtTokenProvider tokenProvider, ApplicationContext applicationContext) {
        this.tokenProvider = tokenProvider;
        this.applicationContext = applicationContext;
    }

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
                                      Authentication authentication) throws IOException {
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        
        String token = tokenProvider.generateToken(userPrincipal.getId());
        String refreshToken = tokenProvider.generateRefreshToken(userPrincipal.getId());
        
        // Get AuthService lazily to avoid circular dependency
        AuthService authService = applicationContext.getBean(AuthService.class);
        authService.updateLastLogin(userPrincipal.getId());
        
        String redirectUrl = UriComponentsBuilder.fromUriString(frontendUrl + "/oauth2/callback")
                .queryParam("token", token)
                .queryParam("refreshToken", refreshToken)
                .build().toUriString();
        
        getRedirectStrategy().sendRedirect(request, response, redirectUrl);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/security/UserPrincipal.java
================
package com.socialapp.Zircuit.security;
import com.fasterxml.jackson.annotation.JsonIgnore;
import com.socialapp.Zircuit.model.entity.User;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.Collections;
import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserPrincipal implements UserDetails {
    private String id;
    private String username;
    private String email;
    
    @JsonIgnore
    private String password;
    
    private Collection<? extends GrantedAuthority> authorities;
    
    public static UserPrincipal create(User user) {
        List<GrantedAuthority> authorities = Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER"));
        
        return UserPrincipal.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .password(user.getPasswordHash())
                .authorities(authorities)
                .build();
    }
    
    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return authorities;
    }
    
    @Override
    public String getPassword() {
        return password;
    }
    
    @Override
    public String getUsername() {
        return username;
    }
    
    @Override
    public boolean isAccountNonExpired() {
        return true;
    }
    
    @Override
    public boolean isAccountNonLocked() {
        return true;
    }
    
    @Override
    public boolean isCredentialsNonExpired() {
        return true;
    }
    
    @Override
    public boolean isEnabled() {
        return true;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/util/SecurityUtils.java
================
package com.socialapp.Zircuit.util;

import com.socialapp.Zircuit.exception.UnauthorizedException;
import com.socialapp.Zircuit.security.UserPrincipal;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.Base64;

/**
 * Utility class for security-related operations
 */
public class SecurityUtils {
    private static final BCryptPasswordEncoder PASSWORD_ENCODER = new BCryptPasswordEncoder();
    private static final SecureRandom SECURE_RANDOM = new SecureRandom();

    /**
     * Get the current authenticated user's ID
     * @return the current user's ID
     * @throws UnauthorizedException if no user is authenticated
     */
    public static String getCurrentUserId() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated() || 
                authentication.getPrincipal().equals("anonymousUser")) {
            throw new UnauthorizedException("Not authenticated");
        }
        
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        return userPrincipal.getId();
    }

    /**
     * Check if the given user ID matches the current authenticated user
     * @param userId the user ID to check
     * @return true if the current user matches the given ID
     */
    public static boolean isCurrentUser(String userId) {
        try {
            return getCurrentUserId().equals(userId);
        } catch (UnauthorizedException e) {
            return false;
        }
    }

    /**
     * Generate a secure token for email verification or password reset
     * @return a random token
     */
    public static String generateSecureToken() {
        byte[] randomBytes = new byte[32];
        SECURE_RANDOM.nextBytes(randomBytes);
        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);
    }

    /**
     * Hash a token using SHA-256
     * @param token the token to hash
     * @return the hashed token
     */
    public static String hashToken(String token) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(token.getBytes());
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Failed to hash token", e);
        }
    }

    /**
     * Encode a password using BCrypt
     * @param password the password to encode
     * @return the encoded password
     */
    public static String encodePassword(String password) {
        return PASSWORD_ENCODER.encode(password);
    }

    /**
     * Check if a password matches an encoded password
     * @param rawPassword the raw password
     * @param encodedPassword the encoded password
     * @return true if the passwords match
     */
    public static boolean matchesPassword(String rawPassword, String encodedPassword) {
        return PASSWORD_ENCODER.matches(rawPassword, encodedPassword);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/util/ValidationUtils.java
================
package com.socialapp.Zircuit.util;

import org.springframework.util.StringUtils;

import java.util.regex.Pattern;

/**
 * Utility class for common validation logic
 */
public class ValidationUtils {
    private static final Pattern EMAIL_PATTERN = 
            Pattern.compile("^[a-zA-Z0-9_+&*-]+(?:\\.[a-zA-Z0-9_+&*-]+)*@(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,7}$");
    
    private static final Pattern USERNAME_PATTERN = 
            Pattern.compile("^[a-zA-Z0-9_]{3,50}$");
    
    private static final Pattern URL_PATTERN = 
            Pattern.compile("^(https?:\\/\\/)?([\\da-z\\.-]+)\\.([a-z\\.]{2,6})([\\/\\w \\.-]*)*\\/?$");

    /**
     * Validates email format
     * @param email the email to validate
     * @return true if the email is valid
     */
    public static boolean isValidEmail(String email) {
        return email != null && EMAIL_PATTERN.matcher(email).matches();
    }

    /**
     * Validates username format (alphanumeric and underscore only, 3-50 chars)
     * @param username the username to validate
     * @return true if the username is valid
     */
    public static boolean isValidUsername(String username) {
        return username != null && USERNAME_PATTERN.matcher(username).matches();
    }

    /**
     * Validates password strength
     * @param password the password to validate
     * @return true if the password is strong enough
     */
    public static boolean isValidPassword(String password) {
        if (password == null || password.length() < 8) {
            return false;
        }
        
        boolean hasUppercase = false;
        boolean hasLowercase = false;
        boolean hasDigit = false;
        
        for (char c : password.toCharArray()) {
            if (Character.isUpperCase(c)) {
                hasUppercase = true;
            } else if (Character.isLowerCase(c)) {
                hasLowercase = true;
            } else if (Character.isDigit(c)) {
                hasDigit = true;
            }
            
            if (hasUppercase && hasLowercase && hasDigit) {
                return true;
            }
        }
        
        return false;
    }

    /**
     * Validates URL format
     * @param url the URL to validate
     * @return true if the URL is valid
     */
    public static boolean isValidUrl(String url) {
        return url == null || url.isEmpty() || URL_PATTERN.matcher(url).matches();
    }

    /**
     * Sanitizes a string by removing potentially dangerous characters
     * @param input the string to sanitize
     * @return the sanitized string
     */
    public static String sanitize(String input) {
        if (!StringUtils.hasText(input)) {
            return input;
        }
        
        // Remove HTML/Script tags
        String sanitized = input.replaceAll("<[^>]*>", "");
        
        // Remove other potentially dangerous characters
        return sanitized.replaceAll("[\\\\\"'`;%]", "");
    }
}

================
File: src/main/resources/application.properties
================
spring.application.name=Zircuit
#debug=true
#logging.level.org.springframework=DEBUG

# Server Configuration
server.port=8080
server.servlet.context-path=/api
app.oauth2.redirectUri=http://localhost:8080/api/auth/oauth2/callback



# Database Configuration
spring.datasource.url=jdbc:mysql://localhost:3306/zircuit?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC&createDatabaseIfNotExist=true
spring.datasource.username=root
spring.datasource.password=mysql1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA/Hibernate Configuration
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.open-in-view=false

# JWT Configuration
app.jwt.secret=9PtxvWUATHTfLcaE05SkbDWdB1Ixnxmw
app.jwt.expirationMs=86400000 
app.jwt.refreshExpirationMs=604800000
app.jwt.header=Authorization
app.jwt.prefix=Bearer
app.verification.tokenExpirationMs=86400000
app.password-reset.tokenExpirationMs=86400000
app.verification.email.sender=akashwishvajith@gmail.com

#File storage configuration
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=10MB
app.file.upload-dir=./uploads

# OAuth2 Configuration
spring.security.oauth2.client.registration.google.client-id=656360199408-j3av4v63fm2g2ipcgv34qfi3masbcs26.apps.googleusercontent.com
spring.security.oauth2.client.registration.google.client-secret=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
spring.security.oauth2.client.registration.google.scope=profile,email

spring.security.oauth2.client.registration.facebook.client-id=1194475925458444
spring.security.oauth2.client.registration.facebook.client-secret=ebafb7d8bb7be7bae308f266540b65c7
spring.security.oauth2.client.registration.facebook.scope=email,public_profile

spring.security.oauth2.client.registration.github.client-id=Ov23lig1Zn2g55z5sP30
spring.security.oauth2.client.registration.github.client-secret=4b50cb31f5b9f343ac02b5b222148c50d81df0b4
spring.security.oauth2.client.registration.github.scope=user:email,read:user

#Email Configuration
spring.mail.host=smtp.gmail.com
spring.mail.port=587
spring.mail.username=akashwishvajith@gmail.com
spring.mail.password=prre teea ofxf tgqz
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.starttls.enable=true
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html

# Logging Configuration
logging.level.com.socialapp.Zircuit=DEBUG
logging.level.org.springframework.scheduling.concurrent=DEBUG
logging.level.org.springframework.web=DEBUG


#  frontend app url (for redirects)
app.frontend.url=http://localhost:5173

# Server compression
server.compression.enabled=true
server.compression.mime-types=application/json,application/xml,text/html,text/xml,text/plain,text/css,text/javascript,application/javascript

# Connection Pool Configuration
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.maximum-pool-size=10
spring.datasource.hikari.minimum-idle=5
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# Actuator Configuration
management.endpoints.web.exposure.include=health,info,metrics
management.endpoint.health.show-details=when_authorized

# Cache Configuration
spring.cache.type=caffeine
spring.cache.caffeine.spec=maximumSize=500,expireAfterAccess=600s

# WebSocket Configuration
spring.mvc.async.request-timeout=30000

================
File: src/main/java/com/socialapp/Zircuit/config/CacheConfig.java
================
package com.socialapp.Zircuit.config;

import com.github.benmanes.caffeine.cache.Caffeine;
import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.caffeine.CaffeineCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.concurrent.TimeUnit;

/**
 * Configuration for caching
 */
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager cacheManager() {
        CaffeineCacheManager cacheManager = new CaffeineCacheManager();
        cacheManager.setCaffeine(Caffeine.newBuilder()
                .maximumSize(500)
                .expireAfterAccess(10, TimeUnit.MINUTES));
        return cacheManager;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/config/CorsConfig.java
================
package com.socialapp.Zircuit.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

import java.util.Arrays;
import java.util.Collections;

/**
 * Configuration for CORS (Cross-Origin Resource Sharing)
 */
@Configuration
public class CorsConfig implements WebMvcConfigurer {
    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins(frontendUrl)
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Collections.singletonList(frontendUrl));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "X-Requested-With"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/config/DataInitializer.java
================
package com.socialapp.Zircuit.config;

import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.model.entity.UserSettings;
import com.socialapp.Zircuit.model.enums.MessagePermission;
import com.socialapp.Zircuit.repository.UserRepository;
import com.socialapp.Zircuit.repository.UserSettingsRepository;
import lombok.extern.slf4j.Slf4j;
//import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Component
@Slf4j
public class DataInitializer implements ApplicationRunner {
    private final UserRepository userRepository;
    private final UserSettingsRepository userSettingsRepository;
    private final PasswordEncoder passwordEncoder;

    //@Autowired
    public DataInitializer(
            UserRepository userRepository,
            UserSettingsRepository userSettingsRepository,
            PasswordEncoder passwordEncoder) {
        this.userRepository = userRepository;
        this.userSettingsRepository = userSettingsRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @Override
    @Transactional
    public void run(ApplicationArguments args) {
        log.info("Initializing application data...");
        
        if (!userRepository.existsByUsername("admin")) {
            createAdminUser();
        }
        
        if (!userRepository.existsByUsername("testuser")) {
            createTestUser();
        }
        
        log.info("Data initialization completed.");
    }

    private void createAdminUser() {
        log.info("Creating admin user...");
        
        User adminUser = User.builder()
                .id(UUID.randomUUID().toString())
                .username("admin")
                .email("admin@example.com")
                .passwordHash(passwordEncoder.encode("admin123"))
                .fullName("System Administrator")
                .isActive(true)
                .isVerified(true)
                .isPublic(true)
                .build();
        
        userRepository.save(adminUser);
        
        UserSettings adminSettings = UserSettings.builder()
                .userId(adminUser.getId())
                .allowMessagesFrom(MessagePermission.ALL)
                .build();
        
        userSettingsRepository.save(adminSettings);
    }

    private void createTestUser() {
        log.info("Creating test user...");
        
        User testUser = User.builder()
                .id(UUID.randomUUID().toString())
                .username("testuser")
                .email("test@example.com")
                .passwordHash(passwordEncoder.encode("test123"))
                .fullName("Test User")
                .bio("This is a test user account for demonstration purposes.")
                .isActive(true)
                .isVerified(true)
                .isPublic(true)
                .build();
        
        userRepository.save(testUser);
        
        UserSettings testSettings = UserSettings.builder()
                .userId(testUser.getId())
                .allowMessagesFrom(MessagePermission.ALL)
                .build();
        
        userSettingsRepository.save(testSettings);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/config/ResponseHandler.java
================
package com.socialapp.Zircuit.config;

import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.converter.HttpMessageConverter;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

import java.util.HashMap;
import java.util.Map;

/**
 * Global handler for shaping API responses
 */
@ControllerAdvice
public class ResponseHandler implements ResponseBodyAdvice<Object> {
    @Override
    public boolean supports(MethodParameter returnType, Class<? extends HttpMessageConverter<?>> converterType) {
        // Only apply to responses that are not already wrapped and not error responses
        return !returnType.getParameterType().equals(Map.class);
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType,
                                 Class<? extends HttpMessageConverter<?>> selectedConverterType,
                                 ServerHttpRequest request, ServerHttpResponse response) {
        
        // Skip wrapping for certain types
        if (body == null || body instanceof byte[] || body instanceof String) {
            return body;
        }
        
        // Skip wrapping for error responses from ExceptionHandler
        if (body instanceof HashMap && ((HashMap<?, ?>) body).containsKey("status") && 
                ((HashMap<?, ?>) body).containsKey("message")) {
            return body;
        }
        
        Map<String, Object> wrapper = new HashMap<>();
        wrapper.put("success", true);
        wrapper.put("data", body);
        return wrapper;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/config/SecurityConfig.java
================
package com.socialapp.Zircuit.config;

import com.socialapp.Zircuit.security.JwtAuthenticationEntryPoint;
import com.socialapp.Zircuit.security.JwtAuthenticationFilter;
import com.socialapp.Zircuit.security.OAuth2AuthenticationSuccessHandler;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(
        securedEnabled = true,
        jsr250Enabled = true,
        prePostEnabled = true
)
public class SecurityConfig {
    private JwtAuthenticationEntryPoint unauthorizedHandler;
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    private OAuth2AuthenticationSuccessHandler oAuth2AuthenticationSuccessHandler;

    @Autowired
    public void setUnauthorizedHandler(JwtAuthenticationEntryPoint unauthorizedHandler) {
        this.unauthorizedHandler = unauthorizedHandler;
    }

    @Autowired
    public void setJwtAuthenticationFilter(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    @Autowired
    public void setOAuth2AuthenticationSuccessHandler( @Lazy OAuth2AuthenticationSuccessHandler handler) {
        this.oAuth2AuthenticationSuccessHandler = handler;
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configure(http))
                .csrf(csrf -> csrf.disable())
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(unauthorizedHandler))
                .sessionManagement(session -> session
                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(authorize -> authorize
                        .requestMatchers("/auth/**", "/oauth2/**").permitAll()
                        .requestMatchers(HttpMethod.GET, "/users/{userID}/profile").permitAll()
                        .requestMatchers(HttpMethod.POST, "/auth/login", "/auth/register", "/auth/refresh-token").permitAll()
                        .requestMatchers(HttpMethod.GET, "/auth/verify-email").permitAll()
                        .requestMatchers(HttpMethod.POST, "/auth/forgot-password", "/auth/reset-password").permitAll()
                        .anyRequest().authenticated())
                .oauth2Login(oauth2 -> oauth2
                        .successHandler(oAuth2AuthenticationSuccessHandler));

        http.addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }
}

================
File: src/main/java/com/socialapp/Zircuit/config/WebSocketConfig.java
================
package com.socialapp.Zircuit.config;

import com.socialapp.Zircuit.security.JwtTokenProvider;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageChannel;
import org.springframework.messaging.simp.config.ChannelRegistration;
import org.springframework.messaging.simp.config.MessageBrokerRegistry;
import org.springframework.messaging.simp.stomp.StompCommand;
import org.springframework.messaging.simp.stomp.StompHeaderAccessor;
import org.springframework.messaging.support.ChannelInterceptor;
import org.springframework.messaging.support.MessageHeaderAccessor;
import org.springframework.security.core.Authentication;
import org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;
import org.springframework.web.socket.config.annotation.StompEndpointRegistry;
import org.springframework.web.socket.config.annotation.WebSocketMessageBrokerConfigurer;

@Configuration
@EnableWebSocketMessageBroker
@Order(Ordered.HIGHEST_PRECEDENCE + 99)
@RequiredArgsConstructor
public class WebSocketConfig implements WebSocketMessageBrokerConfigurer {
    private final JwtTokenProvider jwtTokenProvider;

    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        // Enable a simple memory-based message broker to carry messages back to the client
        // Prefix for messages FROM server TO client
        registry.enableSimpleBroker("/topic");
        
        // Prefix for messages FROM client TO server
        registry.setApplicationDestinationPrefixes("/app");
    }

    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        // Register the "/ws" endpoint, enabling SockJS fallback options
        registry.addEndpoint("/ws")
                .setAllowedOriginPatterns("*")
                .withSockJS();
    }

    @Override
    public void configureClientInboundChannel(ChannelRegistration registration) {
        registration.interceptors(new ChannelInterceptor() {
            @Override
            public Message<?> preSend(Message<?> message, MessageChannel channel) {
                StompHeaderAccessor accessor = MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class);
                
                if (StompCommand.CONNECT.equals(accessor.getCommand())) {
                    String token = accessor.getFirstNativeHeader("Authorization");
                    if (token != null && token.startsWith("Bearer ")) {
                        token = token.substring(7);
                        
                        if (jwtTokenProvider.validateToken(token)) {
                            Authentication auth = jwtTokenProvider.getAuthentication(token);
                            accessor.setUser(auth);
                        }
                    }
                }
                return message;
            }
        });
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/AuthController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.request.LoginRequest;
import com.socialapp.Zircuit.model.dto.request.RegisterRequest;
import com.socialapp.Zircuit.model.dto.response.AuthResponse;
import com.socialapp.Zircuit.service.AuthService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {
    private final AuthService authService;

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> login(@Valid @RequestBody LoginRequest loginRequest) {
        AuthResponse response = authService.login(loginRequest.getEmail(), loginRequest.getPassword());
        return ResponseEntity.ok(response);
    }

    @PostMapping("/register")
    public ResponseEntity<AuthResponse> register(@Valid @RequestBody RegisterRequest registerRequest) {
        AuthResponse response = authService.register(
                registerRequest.getUsername(),
                registerRequest.getEmail(),
                registerRequest.getPassword(),
                registerRequest.getFullName()
        );
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    @GetMapping("/oauth2/{provider}")
    public ResponseEntity<Void> redirectToProvider(@PathVariable String provider) {
        String redirectUrl = authService.getOAuth2RedirectUrl(provider.toUpperCase());
        return ResponseEntity.status(HttpStatus.FOUND)
                .header("Location", redirectUrl)
                .build();
    }

    @PostMapping("/oauth2/{provider}/callback")
    public ResponseEntity<AuthResponse> handleOAuth2Callback(
            @PathVariable String provider,
            @RequestParam String code,
            @RequestParam String state) {
        AuthResponse response = authService.processOAuth2Callback(provider.toUpperCase(), code, state);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/refresh-token")
    public ResponseEntity<AuthResponse> refreshToken(@RequestHeader("Authorization") String refreshToken) {
        if (refreshToken != null && refreshToken.startsWith("Bearer ")) {
            refreshToken = refreshToken.substring(7);
        }
        AuthResponse response = authService.refreshToken(refreshToken);
        return ResponseEntity.ok(response);
    }

    @GetMapping("/verify-email")
    public ResponseEntity<String> verifyEmail(@RequestParam String token) {
        boolean verified = authService.verifyEmail(token);
        if (verified) {
            return ResponseEntity.ok("Email verified successfully");
        }
        return ResponseEntity.badRequest().body("Invalid or expired verification token");
    }

    @PostMapping("/forgot-password")
    public ResponseEntity<String> forgotPassword(@RequestParam String email) {
        authService.sendPasswordResetEmail(email);
        return ResponseEntity.ok("Password reset instructions sent to your email if it exists in our system");
    }

    @PostMapping("/reset-password")
    public ResponseEntity<String> resetPassword(
            @RequestParam String token,
            @RequestParam String newPassword) {
        boolean reset = authService.resetPassword(token, newPassword);
        if (reset) {
            return ResponseEntity.ok("Password reset successfully");
        }
        return ResponseEntity.badRequest().body("Invalid or expired reset token");
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/FollowController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.security.UserPrincipal;
import com.socialapp.Zircuit.service.FollowService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class FollowController {
    private final FollowService followService;

    @PostMapping("/{userID}/follow")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Boolean>> followUser(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @PathVariable String userID) {
        followService.followUser(currentUser.getId(), userID);
        
        Map<String, Boolean> response = new HashMap<>();
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{userID}/follow")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Boolean>> unfollowUser(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @PathVariable String userID) {
        followService.unfollowUser(currentUser.getId(), userID);
        
        Map<String, Boolean> response = new HashMap<>();
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }

    @GetMapping("/{userID}/followers")
    public ResponseEntity<Page<UserSummaryResponse>> getFollowers(
            @PathVariable String userID,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<UserSummaryResponse> followers = followService.getFollowers(userID, pageable);
        return ResponseEntity.ok(followers);
    }

    @GetMapping("/{userID}/following")
    public ResponseEntity<Page<UserSummaryResponse>> getFollowing(
            @PathVariable String userID,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<UserSummaryResponse> following = followService.getFollowing(userID, pageable);
        return ResponseEntity.ok(following);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/MessageController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.request.MessageRequest;
import com.socialapp.Zircuit.model.dto.request.MessageSettingsRequest;
import com.socialapp.Zircuit.model.dto.response.ConversationResponse;
import com.socialapp.Zircuit.model.dto.response.MessageResponse;
import com.socialapp.Zircuit.model.enums.MessagePermission;
import com.socialapp.Zircuit.security.UserPrincipal;
import com.socialapp.Zircuit.service.MessageService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import jakarta.validation.Valid;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/messages")
@RequiredArgsConstructor
public class MessageController {
    private final MessageService messageService;

    @PostMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<MessageResponse> sendMessage(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @Valid @RequestBody MessageRequest request) {
        MessageResponse message = messageService.sendMessage(
                currentUser.getId(),
                request.getReceiverId(),
                request.getContent()
        );
        return ResponseEntity.ok(message);
    }

    @GetMapping("/conversations")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Page<ConversationResponse>> getConversations(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        Pageable pageable = PageRequest.of(page, size);
        Page<ConversationResponse> conversations = messageService.getConversations(currentUser.getId(), pageable);
        return ResponseEntity.ok(conversations);
    }

    @GetMapping("/{userID}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Page<MessageResponse>> getConversation(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @PathVariable String userID,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "50") int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "sentAt"));
        Page<MessageResponse> messages = messageService.getConversation(currentUser.getId(), userID, pageable);
        
        // Mark messages as read
        messageService.markMessagesAsRead(currentUser.getId(), userID);
        
        return ResponseEntity.ok(messages);
    }

    @DeleteMapping("/{messageID}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Boolean>> deleteMessage(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @PathVariable String messageID) {
        messageService.deleteMessage(currentUser.getId(), messageID);
        
        Map<String, Boolean> response = new HashMap<>();
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }

    @PutMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, String>> updateMessageSettings(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @Valid @RequestBody MessageSettingsRequest request) {
        messageService.updateMessageSettings(currentUser.getId(), request.getAllowMessagesFrom());
        
        Map<String, String> response = new HashMap<>();
        response.put("allowMessagesFrom", request.getAllowMessagesFrom().name());
        
        return ResponseEntity.ok(response);
    }

    @GetMapping("/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, String>> getMessageSettings(
            @AuthenticationPrincipal UserPrincipal currentUser) {
        MessagePermission allowMessagesFrom = messageService.getMessageSettings(currentUser.getId());
        
        Map<String, String> response = new HashMap<>();
        response.put("allowMessagesFrom", allowMessagesFrom.name());
        
        return ResponseEntity.ok(response);
    }
    
    @MessageMapping("/send/{receiverId}")
    public void handleWebSocketMessage(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @DestinationVariable String receiverId,
            @Payload String content) {
        messageService.sendMessage(currentUser.getId(), receiverId, content);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/NotificationController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.response.NotificationResponse;
import com.socialapp.Zircuit.security.UserPrincipal;
import com.socialapp.Zircuit.service.NotificationService;
import lombok.RequiredArgsConstructor;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/notifications")
@RequiredArgsConstructor
public class NotificationController {
    private final NotificationService notificationService;

    @GetMapping
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Page<NotificationResponse>> getNotifications(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @RequestParam(defaultValue = "false") boolean unreadOnly,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        Pageable pageable = PageRequest.of(page, size, Sort.by(Sort.Direction.DESC, "createdAt"));
        Page<NotificationResponse> notifications = notificationService.getNotifications(
                currentUser.getId(), unreadOnly, pageable);
        return ResponseEntity.ok(notifications);
    }

    @PutMapping("/{notificationID}/read")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Boolean>> markNotificationAsRead(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @PathVariable String notificationID) {
        notificationService.markNotificationAsRead(currentUser.getId(), notificationID);
        
        Map<String, Boolean> response = new HashMap<>();
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }

    @PutMapping("/read-all")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Boolean>> markAllNotificationsAsRead(
            @AuthenticationPrincipal UserPrincipal currentUser) {
        notificationService.markAllNotificationsAsRead(currentUser.getId());
        
        Map<String, Boolean> response = new HashMap<>();
        response.put("success", true);
        
        return ResponseEntity.ok(response);
    }

    @GetMapping("/unread-count")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, Long>> getUnreadNotificationCount(
            @AuthenticationPrincipal UserPrincipal currentUser) {
        long count = notificationService.countUnreadNotifications(currentUser.getId());
        
        Map<String, Long> response = new HashMap<>();
        response.put("count", count);
        
        return ResponseEntity.ok(response);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/ResourceController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.service.FileStorageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.net.MalformedURLException;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/uploads")
@RequiredArgsConstructor
@Slf4j
public class ResourceController {
    private final FileStorageService fileStorageService;

    @GetMapping("/{fileName:.+}")
    public ResponseEntity<Resource> serveFile(@PathVariable String fileName) {
        try {
            Path filePath = fileStorageService.getFilePath(fileName);
            Resource resource = new UrlResource(filePath.toUri());
            
            if (resource.exists()) {
                String contentType = determineContentType(fileName);
                
                return ResponseEntity.ok()
                        .contentType(MediaType.parseMediaType(contentType))
                        .header(HttpHeaders.CONTENT_DISPOSITION, "inline; filename=\"" + resource.getFilename() + "\"")
                        .body(resource);
            } else {
                log.error("File not found: {}", fileName);
                return ResponseEntity.notFound().build();
            }
        } catch (MalformedURLException e) {
            log.error("Error serving file: {}", fileName, e);
            return ResponseEntity.badRequest().build();
        }
    }

    @GetMapping("/health")
    public ResponseEntity<Map<String, String>> health() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "UP");
        return ResponseEntity.ok(response);
    }

    private String determineContentType(String fileName) {
        fileName = fileName.toLowerCase();
        
        if (fileName.endsWith(".png")) {
            return "image/png";
        } else if (fileName.endsWith(".jpg") || fileName.endsWith(".jpeg")) {
            return "image/jpeg";
        } else if (fileName.endsWith(".gif")) {
            return "image/gif";
        } else if (fileName.endsWith(".svg")) {
            return "image/svg+xml";
        } else if (fileName.endsWith(".pdf")) {
            return "application/pdf";
        } else if (fileName.endsWith(".doc") || fileName.endsWith(".docx")) {
            return "application/msword";
        } else if (fileName.endsWith(".xls") || fileName.endsWith(".xlsx")) {
            return "application/vnd.ms-excel";
        } else if (fileName.endsWith(".zip")) {
            return "application/zip";
        } else if (fileName.endsWith(".mp4")) {
            return "video/mp4";
        } else {
            return "application/octet-stream";
        }
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/UserController.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.request.ProfileUpdateRequest;
import com.socialapp.Zircuit.model.dto.request.SettingsUpdateRequest;
import com.socialapp.Zircuit.model.dto.response.ProfileResponse;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.security.UserPrincipal;
import com.socialapp.Zircuit.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import jakarta.validation.Valid;
import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/users")
@RequiredArgsConstructor
public class UserController {
    private final UserService userService;

    @GetMapping("/{userID}/profile")
    public ResponseEntity<ProfileResponse> getUserProfile(@PathVariable String userID) {
        ProfileResponse profile = userService.getUserProfile(userID);
        return ResponseEntity.ok(profile);
    }

    @PutMapping("/me/profile")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ProfileResponse> updateProfile(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @Valid @RequestBody ProfileUpdateRequest request) {
        ProfileResponse updatedProfile = userService.updateUserProfile(currentUser.getId(), request);
        return ResponseEntity.ok(updatedProfile);
    }

    @PutMapping("/me/settings")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<UserSummaryResponse> updateSettings(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @Valid @RequestBody SettingsUpdateRequest request) {
        UserSummaryResponse updatedUser = userService.updateUserSettings(currentUser.getId(), request);
        return ResponseEntity.ok(updatedUser);
    }

    @PostMapping(value = "/me/avatar", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<Map<String, String>> uploadAvatar(
            @AuthenticationPrincipal UserPrincipal currentUser,
            @RequestParam("file") MultipartFile file) {
        String avatarUrl = userService.uploadAvatar(currentUser.getId(), file);
        
        Map<String, String> response = new HashMap<>();
        response.put("avatarUrl", avatarUrl);
        
        return ResponseEntity.ok(response);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/controller/WebSocketMessageHandler.java
================
package com.socialapp.Zircuit.controller;

import com.socialapp.Zircuit.model.dto.response.MessageResponse;
import com.socialapp.Zircuit.security.UserPrincipal;
import com.socialapp.Zircuit.service.MessageService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.messaging.handler.annotation.DestinationVariable;
import org.springframework.messaging.handler.annotation.MessageMapping;
import org.springframework.messaging.handler.annotation.Payload;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;

@Controller
@RequiredArgsConstructor
@Slf4j
public class WebSocketMessageHandler {
    private final MessageService messageService;

    @MessageMapping("/chat/{receiverId}")
    public void processMessage(Authentication authentication, @DestinationVariable String receiverId, @Payload String content) {
        UserPrincipal currentUser = (UserPrincipal) authentication.getPrincipal();
        log.debug("Received WebSocket message from user {} to {}: {}", currentUser.getId(), receiverId, content);
        
        // Process and save the message using the MessageService
        messageService.sendMessage(currentUser.getId(), receiverId, content);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/VerificationToken.java
================
package com.socialapp.Zircuit.model.entity;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.Instant;
import java.util.UUID;

@Entity
@Table(name = "verification_tokens")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class VerificationToken {
    @Id
    private String id;

    private String token;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private User user;

    private String email; // The email being verified

    private TokenType tokenType;

    private Instant expiryDate;

    private boolean used;

    @PrePersist
    public void prePersist() {
        if (id == null) {
            id = UUID.randomUUID().toString();
        }
    }

    public enum TokenType {
        EMAIL_VERIFICATION,
        PASSWORD_RESET
    }

    public boolean isExpired() {
        return expiryDate.isBefore(Instant.now());
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/AuthService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.BadRequestException;
import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.exception.UnauthorizedException;
import com.socialapp.Zircuit.model.dto.response.AuthResponse;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.model.entity.UserAuth;
import com.socialapp.Zircuit.model.entity.UserSettings;
import com.socialapp.Zircuit.model.enums.AuthProvider;
import com.socialapp.Zircuit.model.enums.MessagePermission;
import com.socialapp.Zircuit.repository.UserAuthRepository;
import com.socialapp.Zircuit.repository.UserRepository;
import com.socialapp.Zircuit.repository.UserSettingsRepository;
import com.socialapp.Zircuit.security.JwtTokenProvider;
import com.socialapp.Zircuit.security.UserPrincipal;
//import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.oauth2.client.registration.ClientRegistration;
import org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.util.LinkedMultiValueMap;
import org.springframework.util.MultiValueMap;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.util.UriComponentsBuilder;
//import org.springframework.context.annotation.Lazy;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.time.LocalDateTime;
import java.util.Base64;
import java.util.Map;
import java.util.UUID;

@Service
@Slf4j
public class AuthService {
    private final UserRepository userRepository;
    private final UserAuthRepository userAuthRepository;
    private final UserSettingsRepository userSettingsRepository;
    private final JwtTokenProvider tokenProvider;
    private final EmailService emailService;
    private final ClientRegistrationRepository clientRegistrationRepository;
    private final RestTemplate restTemplate = new RestTemplate();
    private PasswordEncoder passwordEncoder;
    private AuthenticationManager authenticationManager;

    public AuthService(
            UserRepository userRepository,
            UserAuthRepository userAuthRepository,
            UserSettingsRepository userSettingsRepository,
            JwtTokenProvider tokenProvider,
            EmailService emailService,
            ClientRegistrationRepository clientRegistrationRepository
            ) {
        this.userRepository = userRepository;
        this.userAuthRepository = userAuthRepository;
        this.userSettingsRepository = userSettingsRepository;
        this.tokenProvider = tokenProvider;
        this.emailService = emailService;
        this.clientRegistrationRepository = clientRegistrationRepository;
    
    }

    @Autowired
    public void setAuthenticationManager(AuthenticationManager authenticationManager) {
        this.authenticationManager = authenticationManager;
    }

    @Autowired
    public void setPasswordEncoder(PasswordEncoder passwordEncoder) {
        this.passwordEncoder = passwordEncoder; // Setter injection
    }

    @Value("${app.oauth2.redirectUri}")
    private String redirectUri;

    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Value("${app.verification.tokenExpirationMs}")
    private long verificationTokenExpirationMs;

    @Value("${app.password-reset.tokenExpirationMs}")
    private long passwordResetTokenExpirationMs;

    @Transactional
    public AuthResponse login(String email, String password) {
        Authentication authentication = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(email, password)
        );

        SecurityContextHolder.getContext().setAuthentication(authentication);
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();

        String accessToken = tokenProvider.generateToken(userPrincipal.getId());
        String refreshToken = tokenProvider.generateRefreshToken(userPrincipal.getId());

        updateLastLogin(userPrincipal.getId());

        User user = userRepository.findById(userPrincipal.getId())
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userPrincipal.getId()));

        return AuthResponse.builder()
                .token(accessToken)
                .refreshToken(refreshToken)
                .user(mapUserToUserSummaryResponse(user))
                .build();
    }

    @Transactional
    public AuthResponse register(String username, String email, String password, String fullName) {
        if (userRepository.existsByUsername(username)) {
            throw new BadRequestException("Username is already taken");
        }

        if (userRepository.existsByEmail(email)) {
            throw new BadRequestException("Email is already registered");
        }

        User user = User.builder()
                .id(UUID.randomUUID().toString())
                .username(username)
                .email(email)
                .passwordHash(passwordEncoder.encode(password))
                .fullName(fullName)
                .isActive(true)
                .isVerified(false)
                .isPublic(false)
                .build();

        User savedUser = userRepository.save(user);

        UserSettings userSettings = UserSettings.builder()
                .userId(savedUser.getId())
                .allowMessagesFrom(MessagePermission.ALL)
                .build();

        userSettingsRepository.save(userSettings);

        sendVerificationEmail(savedUser);

        String accessToken = tokenProvider.generateToken(savedUser.getId());
        String refreshToken = tokenProvider.generateRefreshToken(savedUser.getId());

        return AuthResponse.builder()
                .token(accessToken)
                .refreshToken(refreshToken)
                .user(mapUserToUserSummaryResponse(savedUser))
                .build();
    }

    @Transactional
    public String getOAuth2RedirectUrl(String provider) {
        try {
            // Map provider string to registration ID
            String registrationId = provider.toLowerCase();
            ClientRegistration clientRegistration = clientRegistrationRepository.findByRegistrationId(registrationId);

            if (clientRegistration == null) {
                throw new BadRequestException("Unsupported auth provider: " + provider);
            }

            String authUrl = clientRegistration.getProviderDetails().getAuthorizationUri();
            String clientId = clientRegistration.getClientId();
            String scope = String.join(" ", clientRegistration.getScopes());

            String state = generateRandomState();

            return UriComponentsBuilder.fromUriString(authUrl)
                    .queryParam("client_id", clientId)
                    .queryParam("redirect_uri", redirectUri)
                    .queryParam("scope", scope)
                    .queryParam("response_type", "code")
                    .queryParam("state", state)
                    .build()
                    .toUriString();

        } catch (IllegalArgumentException e) {
            throw new BadRequestException("Invalid auth provider: " + provider);
        }
    }

    private String generateRandomState() {
        return UUID.randomUUID().toString();
    }

    @Transactional
    public AuthResponse processOAuth2Callback(String provider, String code, String state) {
        try {
            String registrationId = provider.toLowerCase();
            ClientRegistration clientRegistration = clientRegistrationRepository.findByRegistrationId(registrationId);

            if (clientRegistration == null) {
                throw new BadRequestException("Unsupported auth provider: " + provider);
            }

            AuthProvider authProvider = AuthProvider.valueOf(provider.toUpperCase());

            Map<String, Object> tokenResponse = exchangeCodeForToken(authProvider, code, clientRegistration);
            String accessToken = (String) tokenResponse.get("access_token");
            String refreshToken = (String) tokenResponse.getOrDefault("refresh_token", "");
            Integer expiresIn = (Integer) tokenResponse.getOrDefault("expires_in", 3600);

            Map<String, Object> userInfo = getUserInfoFromProvider(authProvider, accessToken);
            if (userInfo == null) {
                throw new BadRequestException("Unable to retrieve user info from " + provider);
            }

            String providerUserId = userInfo.get("id").toString();
            String email = userInfo.getOrDefault("email", "").toString();
            String name = userInfo.getOrDefault("name", "").toString();

            UserAuth userAuth = userAuthRepository.findByProviderAndProviderUserId(authProvider, providerUserId)
                    .orElse(null);

            User user;

            if (userAuth == null) {
                if (!email.isEmpty() && userRepository.existsByEmail(email)) {
                    User existingUser = userRepository.findByEmail(email)
                            .orElseThrow(() -> new ResourceNotFoundException("User", "email", email));

                    userAuth = UserAuth.builder()
                            .userId(existingUser.getId())
                            .provider(authProvider)
                            .providerUserId(providerUserId)
                            .accessTokenHash(hashToken(accessToken))
                            .refreshTokenHash(refreshToken.isEmpty() ? null : hashToken(refreshToken))
                            .expiryTime(LocalDateTime.now().plusSeconds(expiresIn))
                            .build();

                    userAuthRepository.save(userAuth);

                    user = existingUser;
                } else {
                    String username = generateUniqueUsername(name.isEmpty() ? "user" : name);

                    user = User.builder()
                            .id(UUID.randomUUID().toString())
                            .username(username)
                            .email(email.isEmpty() ? null : email)
                            .fullName(name.isEmpty() ? "OAuth User" : name)
                            .isActive(true)
                            .isVerified(!email.isEmpty())
                            .isPublic(false)
                            .build();

                    user = userRepository.save(user);

                    userAuth = UserAuth.builder()
                            .userId(user.getId())
                            .provider(authProvider)
                            .providerUserId(providerUserId)
                            .accessTokenHash(hashToken(accessToken))
                            .refreshTokenHash(refreshToken.isEmpty() ? null : hashToken(refreshToken))
                            .expiryTime(LocalDateTime.now().plusSeconds(expiresIn))
                            .build();

                    userAuthRepository.save(userAuth);

                    UserSettings userSettings = UserSettings.builder()
                            .userId(user.getId())
                            .allowMessagesFrom(MessagePermission.ALL)
                            .build();

                    userSettingsRepository.save(userSettings);
                }
            } else {
                final UserAuth finalUserAuth = userAuth;
                user = userRepository.findById(finalUserAuth.getUserId())
                        .orElseThrow(() -> new ResourceNotFoundException("User", "id", finalUserAuth.getUserId()));

                userAuth.setAccessTokenHash(hashToken(accessToken));
                userAuth.setRefreshTokenHash(refreshToken.isEmpty() ? userAuth.getRefreshTokenHash() : hashToken(refreshToken));
                userAuth.setExpiryTime(LocalDateTime.now().plusSeconds(expiresIn));
                userAuthRepository.save(userAuth);

                if (user.getFullName() == null || user.getFullName().isEmpty()) {
                    user.setFullName(name.isEmpty() ? "OAuth User" : name);
                    userRepository.save(user);
                }
            }

            updateLastLogin(user.getId());

            String jwtAccessToken = tokenProvider.generateToken(user.getId());
            String jwtRefreshToken = tokenProvider.generateRefreshToken(user.getId());

            return AuthResponse.builder()
                    .token(jwtAccessToken)
                    .refreshToken(jwtRefreshToken)
                    .user(mapUserToUserSummaryResponse(user))
                    .build();

        } catch (IllegalArgumentException e) {
            throw new BadRequestException("Invalid auth provider: " + provider);
        } catch (Exception e) {
            log.error("Error processing OAuth2 callback", e);
            throw new BadRequestException("Failed to process OAuth2 callback: " + e.getMessage());
        }
    }

    private Map<String, Object> exchangeCodeForToken(AuthProvider provider, String code, ClientRegistration clientRegistration) {
        String tokenUrl = clientRegistration.getProviderDetails().getTokenUri();
        String clientId = clientRegistration.getClientId();
        String clientSecret = clientRegistration.getClientSecret();

        HttpHeaders headers = new HttpHeaders();
        headers.add("Accept", "application/json");

        MultiValueMap<String, String> params = new LinkedMultiValueMap<>();
        params.add("client_id", clientId);
        params.add("client_secret", clientSecret);
        params.add("code", code);
        params.add("redirect_uri", redirectUri);
        params.add("grant_type", "authorization_code");

        HttpEntity<MultiValueMap<String, String>> request = new HttpEntity<>(params, headers);

        ResponseEntity<Map> response = restTemplate.exchange(
                tokenUrl,
                HttpMethod.POST,
                request,
                Map.class
        );
        @SuppressWarnings("unchecked")
        Map<String, Object> body = response.getBody();
        return body;
    }

    private Map<String, Object> getUserInfoFromProvider(AuthProvider provider, String accessToken) {
        String userInfoUrl;

        switch (provider) {
            case GOOGLE:
                userInfoUrl = "https://www.googleapis.com/oauth2/v3/userinfo";
                break;
            case FACEBOOK:
                userInfoUrl = "https://graph.facebook.com/me?fields=id,name,email";
                break;
            case GITHUB:
                userInfoUrl = "https://api.github.com/user";
                break;
            default:
                throw new BadRequestException("Unsupported auth provider: " + provider);
        }

        HttpHeaders headers = new HttpHeaders();
        headers.add("Authorization", "Bearer " + accessToken);

        HttpEntity<String> request = new HttpEntity<>(headers);

        ResponseEntity<Map> response = restTemplate.exchange(
                userInfoUrl,
                HttpMethod.GET,
                request,
                Map.class
        );
        @SuppressWarnings("unchecked")
        Map<String, Object> userInfo = response.getBody();
        if (userInfo == null) {
            return null;
        }

        if (provider == AuthProvider.GITHUB && (!userInfo.containsKey("email") || userInfo.get("email") == null)) {
            String emailUrl = "https://api.github.com/user/emails";
            ResponseEntity<Map[]> emailResponse = restTemplate.exchange(
                    emailUrl,
                    HttpMethod.GET,
                    request,
                    Map[].class
            );

            @SuppressWarnings("unchecked")
            Map<String, Object>[] emails = emailResponse.getBody();
            if (emails != null && emails.length > 0) {
                for (Map<String, Object> emailObj : emails) {
                    if (Boolean.TRUE.equals(emailObj.get("primary"))) {
                        userInfo.put("email", emailObj.get("email"));
                        break;
                    }
                }

                if (!userInfo.containsKey("email") && emails.length > 0) {
                    userInfo.put("email", emails[0].get("email"));
                }
            }
        }

        return userInfo;
    }

    private String generateUniqueUsername(String baseName) {
        String sanitizedName = baseName.replaceAll("[^a-zA-Z0-9]", "").toLowerCase();

        if (sanitizedName.length() < 3) {
            sanitizedName = "user" + sanitizedName;
        }

        if (sanitizedName.length() > 15) {
            sanitizedName = sanitizedName.substring(0, 15);
        }

        String username = sanitizedName;
        int attempt = 1;

        while (userRepository.existsByUsername(username)) {
            username = sanitizedName + attempt;
            attempt++;
        }

        return username;
    }

    private String hashToken(String token) {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            byte[] hash = digest.digest(token.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(hash);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Failed to hash token", e);
        }
    }

    @Transactional
    public AuthResponse refreshToken(String refreshToken) {
        if (!tokenProvider.validateToken(refreshToken)) {
            throw new UnauthorizedException("Invalid refresh token");
        }

        String userId = tokenProvider.getUserIdFromToken(refreshToken);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));

        String accessToken = tokenProvider.generateToken(userId);
        String newRefreshToken = tokenProvider.generateRefreshToken(userId);

        return AuthResponse.builder()
                .token(accessToken)
                .refreshToken(newRefreshToken)
                .user(mapUserToUserSummaryResponse(user))
                .build();
    }

    @Transactional
    public void updateLastLogin(String userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));

        user.setLastLoginAt(LocalDateTime.now());
        userRepository.save(user);
    }

    private void sendVerificationEmail(User user) {
        String token = generateVerificationToken(user.getId());
        emailService.sendVerificationEmail(user.getEmail(), token, user.getFullName());
    }

    private String generateVerificationToken(String userId) {
        return tokenProvider.generateEmailVerificationToken(userId);
    }

    @Transactional
    public void sendPasswordResetEmail(String email) {
        User user = userRepository.findByEmail(email)
                .orElse(null);
        if (user != null) {
            String token = generatePasswordResetToken(user.getId());
            emailService.sendPasswordResetEmail(user.getEmail(), token, user.getFullName());
        }
    }

    private String generatePasswordResetToken(String userId) {
        return tokenProvider.generatePasswordResetToken(userId);
    }

    @Transactional
    public boolean verifyEmail(String token) {
        try {
            if (!tokenProvider.validateToken(token)) {
                return false;
            }

            String userId = tokenProvider.getUserIdFromToken(token);
            User user = userRepository.findById(userId)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));

            if (user.isVerified()) {
                return true;
            }

            user.setVerified(true);
            userRepository.save(user);

            return true;
        } catch (Exception e) {
            log.error("Error verifying email", e);
            return false;
        }
    }

    @Transactional
    public boolean resetPassword(String token, String newPassword) {
        try {
            if (!tokenProvider.validateToken(token)) {
                return false;
            }

            String userId = tokenProvider.getUserIdFromToken(token);
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));

            user.setPasswordHash(passwordEncoder.encode(newPassword));
            userRepository.save(user);

            return true;
        } catch (Exception e) {
            log.error("Error resetting password", e);
            return false;
        }
    }

    private UserSummaryResponse mapUserToUserSummaryResponse(User user) {
        return UserSummaryResponse.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .fullName(user.getFullName())
                .avatarUrl(user.getAvatarUrl())
                .isPublic(user.isPublic())
                .isVerified(user.isVerified())
                .build();
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/EmailService.java
================
package com.socialapp.Zircuit.service;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.thymeleaf.TemplateEngine;
import org.thymeleaf.context.Context;

import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import java.nio.charset.StandardCharsets;
import java.util.Map;

@Service
@RequiredArgsConstructor
@Slf4j
public class EmailService {
    private final JavaMailSender mailSender;
    private final TemplateEngine templateEngine;

    @Value("${spring.mail.username}")
    private String fromEmail;
    
    @Value("${app.frontend.url}")
    private String frontendUrl;

    @Async
    public void sendEmail(String to, String subject, String templateName, Map<String, Object> templateModel) {
        try {
            MimeMessage message = mailSender.createMimeMessage();
            MimeMessageHelper helper = new MimeMessageHelper(message,
                    MimeMessageHelper.MULTIPART_MODE_MIXED_RELATED,
                    StandardCharsets.UTF_8.name());

            Context context = new Context();
            context.setVariables(templateModel);
            String html = templateEngine.process(templateName, context);

            helper.setTo(to);
            helper.setSubject(subject);
            helper.setText(html, true);
            helper.setFrom(fromEmail);

            mailSender.send(message);
            log.info("Email sent to: {}", to);
        } catch (MessagingException e) {
            log.error("Failed to send email to {}: {}", to, e.getMessage());
        }
    }

    public void sendVerificationEmail(String to, String token, String name) {
        String verificationUrl = frontendUrl + "/verify-email?token=" + token;
        
        Map<String, Object> templateModel = Map.of(
                "name", name,
                "verificationUrl", verificationUrl
        );
        
        sendEmail(to, "Verify Your Email Address", "email-verification", templateModel);
    }

    public void sendPasswordResetEmail(String to, String token, String name) {
        String resetUrl = frontendUrl + "/reset-password?token=" + token;
        
        Map<String, Object> templateModel = Map.of(
                "name", name,
                "resetUrl", resetUrl
        );
        
        sendEmail(to, "Reset Your Password", "password-reset", templateModel);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/FileStorageService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.BadRequestException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.StringUtils;
import org.springframework.web.multipart.MultipartFile;

import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.UUID;

@Service
@Slf4j
public class FileStorageService {
    @Value("${app.file.upload-dir}")
    private String uploadDir;

    private Path fileStorageLocation;

    @PostConstruct
    public void init() {
        this.fileStorageLocation = Paths.get(uploadDir).toAbsolutePath().normalize();
        try {
            Files.createDirectories(this.fileStorageLocation);
        } catch (IOException ex) {
            throw new RuntimeException("Could not create the directory where the uploaded files will be stored.", ex);
        }
    }

    public String storeFile(MultipartFile file) {
        // Validate file
        if (file.isEmpty()) {
            throw new BadRequestException("File cannot be empty");
        }

        // Check file size (max 10MB)
        if (file.getSize() > 10 * 1024 * 1024) {
            throw new BadRequestException("File size exceeds maximum limit (10MB)");
        }

        // Normalize file name
        String originalFileName = StringUtils.cleanPath(file.getOriginalFilename());
        
        // Check if the filename contains invalid characters
        if (originalFileName.contains("..")) {
            throw new BadRequestException("Filename contains invalid path sequence: " + originalFileName);
        }

        try {
            // Generate a unique filename to prevent overwriting
            String fileExtension = getFileExtension(originalFileName);
            String newFileName = UUID.randomUUID().toString() + fileExtension;
            
            // Copy file to the target location
            Path targetLocation = this.fileStorageLocation.resolve(newFileName);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);

            return newFileName;
        } catch (IOException ex) {
            throw new BadRequestException("Could not store file " + originalFileName + ". Please try again.", ex);
        }
    }

    public Path getFilePath(String fileName) {
        return this.fileStorageLocation.resolve(fileName).normalize();
    }

    private String getFileExtension(String fileName) {
        if (fileName.lastIndexOf(".") != -1 && fileName.lastIndexOf(".") != 0) {
            return fileName.substring(fileName.lastIndexOf("."));
        } else {
            return "";
        }
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/FollowService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.BadRequestException;
import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.model.entity.Follow;
import com.socialapp.Zircuit.model.entity.Notification;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.model.enums.NotificationType;
import com.socialapp.Zircuit.repository.FollowRepository;
import com.socialapp.Zircuit.repository.NotificationRepository;
import com.socialapp.Zircuit.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class FollowService {
    private final FollowRepository followRepository;
    private final UserRepository userRepository;
    private final NotificationRepository notificationRepository;

    @Transactional
    public void followUser(String followerId, String followedId) {
        // Check if users exist
        User follower = userRepository.findById(followerId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", followerId));
        
        User followed = userRepository.findById(followedId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", followedId));
        
        // Check if user is trying to follow themselves
        if (followerId.equals(followedId)) {
            throw new BadRequestException("You cannot follow yourself");
        }
        
        // Check if already following
        if (followRepository.existsByIdFollowerIdAndIdFollowedId(followerId, followedId)) {
            throw new BadRequestException("You are already following this user");
        }
        
        // Create follow relationship
        Follow follow = Follow.builder()
                .id(new Follow.FollowId(followerId, followedId))
                .build();
        
        followRepository.save(follow);
        
        // Create notification
        Notification notification = Notification.builder()
                .id(UUID.randomUUID().toString())
                .userId(followedId)
                .actorId(followerId)
                .type(NotificationType.FOLLOW)
                .content(follower.getUsername() + " started following you")
                .build();
        
        notificationRepository.save(notification);
    }
    
    @Transactional
    public void unfollowUser(String followerId, String followedId) {
        // Check if users exist
        if (!userRepository.existsById(followerId)) {
            throw new ResourceNotFoundException("User", "id", followerId);
        }
        
        if (!userRepository.existsById(followedId)) {
            throw new ResourceNotFoundException("User", "id", followedId);
        }
        
        // Check if user is trying to unfollow themselves
        if (followerId.equals(followedId)) {
            throw new BadRequestException("You cannot unfollow yourself");
        }
        
        // Check if follow relationship exists
        if (!followRepository.existsByIdFollowerIdAndIdFollowedId(followerId, followedId)) {
            throw new BadRequestException("You are not following this user");
        }
        
        // Delete follow relationship
        Follow.FollowId followId = new Follow.FollowId(followerId, followedId);
        followRepository.deleteById(followId);
    }
    
    @Transactional(readOnly = true)
    public Page<UserSummaryResponse> getFollowers(String userId, Pageable pageable) {
        // Check if user exists
        if (!userRepository.existsById(userId)) {
            throw new ResourceNotFoundException("User", "id", userId);
        }
        
        // Get followers
        return followRepository.findByIdFollowedId(userId, pageable)
                .map(follow -> {
                    User follower = follow.getFollower();
                    return UserSummaryResponse.builder()
                            .id(follower.getId())
                            .username(follower.getUsername())
                            .email(follower.getEmail())
                            .fullName(follower.getFullName())
                            .avatarUrl(follower.getAvatarUrl())
                            .isPublic(follower.isPublic())
                            .isVerified(follower.isVerified())
                            .build();
                });
    }
    
    @Transactional(readOnly = true)
    public Page<UserSummaryResponse> getFollowing(String userId, Pageable pageable) {
        // Check if user exists
        if (!userRepository.existsById(userId)) {
            throw new ResourceNotFoundException("User", "id", userId);
        }
        
        // Get following
        return followRepository.findByIdFollowerId(userId, pageable)
                .map(follow -> {
                    User followed = follow.getFollowed();
                    return UserSummaryResponse.builder()
                            .id(followed.getId())
                            .username(followed.getUsername())
                            .email(followed.getEmail())
                            .fullName(followed.getFullName())
                            .avatarUrl(followed.getAvatarUrl())
                            .isPublic(followed.isPublic())
                            .isVerified(followed.isVerified())
                            .build();
                });
    }
    
    @Transactional(readOnly = true)
    public boolean isFollowing(String followerId, String followedId) {
        return followRepository.existsByIdFollowerIdAndIdFollowedId(followerId, followedId);
    }
    
    @Transactional(readOnly = true)
    public long getFollowerCount(String userId) {
        return followRepository.countFollowersByUserId(userId);
    }
    
    @Transactional(readOnly = true)
    public long getFollowingCount(String userId) {
        return followRepository.countFollowingByUserId(userId);
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/MessageService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.BadRequestException;
import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.exception.UnauthorizedException;
import com.socialapp.Zircuit.model.dto.response.ConversationResponse;
import com.socialapp.Zircuit.model.dto.response.MessageResponse;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.model.entity.Message;
import com.socialapp.Zircuit.model.entity.Notification;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.model.entity.UserSettings;
import com.socialapp.Zircuit.model.enums.MessagePermission;
import com.socialapp.Zircuit.model.enums.NotificationType;
import com.socialapp.Zircuit.repository.FollowRepository;
import com.socialapp.Zircuit.repository.MessageRepository;
import com.socialapp.Zircuit.repository.NotificationRepository;
import com.socialapp.Zircuit.repository.UserRepository;
import com.socialapp.Zircuit.repository.UserSettingsRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageImpl;
import org.springframework.data.domain.Pageable;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;
import java.util.UUID;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
@Slf4j
public class MessageService {
    private final MessageRepository messageRepository;
    private final UserRepository userRepository;
    private final UserSettingsRepository userSettingsRepository;
    private final FollowRepository followRepository;
    private final NotificationRepository notificationRepository;
    private final SimpMessagingTemplate messagingTemplate;

    @Transactional
    public MessageResponse sendMessage(String senderId, String receiverId, String content) {
        // Check if users exist
        User sender = userRepository.findById(senderId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", senderId));
        
        User receiver = userRepository.findById(receiverId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", receiverId));
        
        // Check if sender is trying to message themselves
        if (senderId.equals(receiverId)) {
            throw new BadRequestException("You cannot send a message to yourself");
        }
        
        // Check receiver's message permission settings
        UserSettings receiverSettings = userSettingsRepository.findByUserId(receiverId)
                .orElseGet(() -> {
                    // Create default settings if not exists
                    UserSettings settings = UserSettings.builder()
                            .userId(receiverId)
                            .allowMessagesFrom(MessagePermission.ALL)
                            .build();
                    return userSettingsRepository.save(settings);
                });
        
        // Check if sender is allowed to send message based on receiver's settings
        if (receiverSettings.getAllowMessagesFrom() == MessagePermission.NONE) {
            throw new UnauthorizedException("This user doesn't accept messages");
        } else if (receiverSettings.getAllowMessagesFrom() == MessagePermission.FOLLOWING) {
            // Check if receiver follows sender
            boolean isFollowing = followRepository.existsByIdFollowerIdAndIdFollowedId(receiverId, senderId);
            if (!isFollowing) {
                throw new UnauthorizedException("This user only accepts messages from people they follow");
            }
        }
        
        // Create message
        Message message = Message.builder()
                .id(UUID.randomUUID().toString())
                .senderId(senderId)
                .receiverId(receiverId)
                .content(content)
                .build();
        
        Message savedMessage = messageRepository.save(message);
        
        // Create notification for receiver
        Notification notification = Notification.builder()
                .id(UUID.randomUUID().toString())
                .userId(receiverId)
                .actorId(senderId)
                .type(NotificationType.MESSAGE)
                .content("New message from " + sender.getUsername())
                .referenceId(savedMessage.getId())
                .build();
        
        notificationRepository.save(notification);
        
        // Send real-time notification via WebSocket
        messagingTemplate.convertAndSend("/topic/messages/" + receiverId, mapMessageToResponse(savedMessage));
        messagingTemplate.convertAndSend("/topic/notifications/" + receiverId, notification);
        
        return mapMessageToResponse(savedMessage);
    }
    
    @Transactional(readOnly = true)
    public Page<MessageResponse> getConversation(String user1Id, String user2Id, Pageable pageable) {
        // Check if users exist
        if (!userRepository.existsById(user1Id)) {
            throw new ResourceNotFoundException("User", "id", user1Id);
        }
        
        if (!userRepository.existsById(user2Id)) {
            throw new ResourceNotFoundException("User", "id", user2Id);
        }
        
        // Get messages between the two users
        return messageRepository.findConversation(user1Id, user2Id, pageable)
                .map(this::mapMessageToResponse);
    }
    
    @Transactional
    public void markMessagesAsRead(String userId, String otherUserId) {
        Page<Message> messages = messageRepository.findConversation(userId, otherUserId, Pageable.unpaged());
        
        messages.forEach(message -> {
            if (message.getReceiverId().equals(userId) && !message.isRead()) {
                message.setRead(true);
                messageRepository.save(message);
            }
        });
    }
    
    @Transactional
    public void deleteMessage(String userId, String messageId) {
        Message message = messageRepository.findById(messageId)
                .orElseThrow(() -> new ResourceNotFoundException("Message", "id", messageId));
        
        // Check if user is sender or receiver
        if (message.getSenderId().equals(userId)) {
            message.setDeletedBySender(true);
        } else if (message.getReceiverId().equals(userId)) {
            message.setDeletedByReceiver(true);
        } else {
            throw new UnauthorizedException("You are not authorized to delete this message");
        }
        
        // If both sender and receiver have deleted, we could physically delete the message
        if (message.isDeletedBySender() && message.isDeletedByReceiver()) {
            messageRepository.delete(message);
        } else {
            messageRepository.save(message);
        }
    }
    
    @Transactional(readOnly = true)
    public Page<ConversationResponse> getConversations(String userId, Pageable pageable) {
        // Get conversation partners
        List<Object[]> conversations = messageRepository.findConversationPartners(userId, pageable);
        
        List<ConversationResponse> conversationResponses = new ArrayList<>();
        
        for (Object[] conversation : conversations) {
            String otherUserId = (String) conversation[0];
            
            // Get user details
            User otherUser = userRepository.findById(otherUserId)
                    .orElseThrow(() -> new ResourceNotFoundException("User", "id", otherUserId));
            
            // Get latest message
            Page<Message> messages = messageRepository.findConversation(userId, otherUserId, Pageable.ofSize(1));
            Message latestMessage = messages.getContent().isEmpty() ? null : messages.getContent().get(0);
            
            // Get unread count
            long unreadCount = messageRepository.countUnreadMessagesFromUser(userId, otherUserId);
            
            UserSummaryResponse userSummary = UserSummaryResponse.builder()
                    .id(otherUser.getId())
                    .username(otherUser.getUsername())
                    .email(otherUser.getEmail())
                    .fullName(otherUser.getFullName())
                    .avatarUrl(otherUser.getAvatarUrl())
                    .isPublic(otherUser.isPublic())
                    .isVerified(otherUser.isVerified())
                    .build();
            
            ConversationResponse conversationResponse = ConversationResponse.builder()
                    .user(userSummary)
                    .latestMessage(latestMessage != null ? mapMessageToResponse(latestMessage) : null)
                    .unreadCount(unreadCount)
                    .lastActivity(latestMessage != null ? latestMessage.getSentAt() : null)
                    .build();
            
            conversationResponses.add(conversationResponse);
        }
        
        return new PageImpl<>(conversationResponses);
    }
    
    @Transactional
    public void updateMessageSettings(String userId, MessagePermission allowMessagesFrom) {
        UserSettings userSettings = userSettingsRepository.findByUserId(userId)
                .orElseGet(() -> {
                    // Create default settings if not exists
                    UserSettings settings = UserSettings.builder()
                            .userId(userId)
                            .allowMessagesFrom(MessagePermission.ALL)
                            .build();
                    return userSettingsRepository.save(settings);
                });
        
        userSettings.setAllowMessagesFrom(allowMessagesFrom);
        userSettingsRepository.save(userSettings);
    }
    
    @Transactional(readOnly = true)
    public MessagePermission getMessageSettings(String userId) {
        return userSettingsRepository.findByUserId(userId)
                .map(UserSettings::getAllowMessagesFrom)
                .orElse(MessagePermission.ALL);
    }
    
    @Transactional(readOnly = true)
    public long countUnreadMessages(String userId) {
        return messageRepository.countUnreadMessages(userId);
    }
    
    private MessageResponse mapMessageToResponse(Message message) {
        return MessageResponse.builder()
                .id(message.getId())
                .senderId(message.getSenderId())
                .receiverId(message.getReceiverId())
                .content(message.getContent())
                .isRead(message.isRead())
                .sentAt(message.getSentAt())
                .build();
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/NotificationService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.model.dto.response.NotificationResponse;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.model.entity.Notification;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.repository.NotificationRepository;
import com.socialapp.Zircuit.repository.UserRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.messaging.simp.SimpMessagingTemplate;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationService {
    private final NotificationRepository notificationRepository;
    private final UserRepository userRepository;
    private final SimpMessagingTemplate messagingTemplate;

    @Transactional(readOnly = true)
    public Page<NotificationResponse> getNotifications(String userId, boolean unreadOnly, Pageable pageable) {
        Page<Notification> notifications;
        
        if (unreadOnly) {
            notifications = notificationRepository.findByUserIdAndIsReadOrderByCreatedAtDesc(userId, false, pageable);
        } else {
            notifications = notificationRepository.findByUserIdOrderByCreatedAtDesc(userId, pageable);
        }
        
        return notifications.map(this::mapNotificationToResponse);
    }
    
    @Transactional
    public void markNotificationAsRead(String userId, String notificationId) {
        Notification notification = notificationRepository.findById(notificationId)
                .orElseThrow(() -> new ResourceNotFoundException("Notification", "id", notificationId));
        
        // Ensure notification belongs to the user
        if (!notification.getUserId().equals(userId)) {
            throw new ResourceNotFoundException("Notification", "id", notificationId);
        }
        
        notification.setRead(true);
        notificationRepository.save(notification);
    }
    
    @Transactional
    public void markAllNotificationsAsRead(String userId) {
        notificationRepository.markAllAsRead(userId);
    }
    
    @Transactional
    public void createNotification(String userId, String actorId, String content, String referenceId, 
                                  com.socialapp.Zircuit.model.enums.NotificationType type) {
        // Validate user exists
        if (!userRepository.existsById(userId)) {
            throw new ResourceNotFoundException("User", "id", userId);
        }
        
        // Validate actor exists if provided
        if (actorId != null && !userRepository.existsById(actorId)) {
            throw new ResourceNotFoundException("User", "id", actorId);
        }
        
        // Create notification
        Notification notification = Notification.builder()
                .id(UUID.randomUUID().toString())
                .userId(userId)
                .actorId(actorId)
                .content(content)
                .referenceId(referenceId)
                .type(type)
                .build();
        
        Notification savedNotification = notificationRepository.save(notification);
        
        // Send real-time notification via WebSocket
        NotificationResponse response = mapNotificationToResponse(savedNotification);
        messagingTemplate.convertAndSend("/topic/notifications/" + userId, response);
    }
    
    @Transactional(readOnly = true)
    public long countUnreadNotifications(String userId) {
        return notificationRepository.countUnreadNotifications(userId);
    }
    
    private NotificationResponse mapNotificationToResponse(Notification notification) {
        UserSummaryResponse actor = null;
        
        if (notification.getActorId() != null) {
            User actorUser = userRepository.findById(notification.getActorId())
                    .orElse(null);
            
            if (actorUser != null) {
                actor = UserSummaryResponse.builder()
                        .id(actorUser.getId())
                        .username(actorUser.getUsername())
                        .email(actorUser.getEmail())
                        .fullName(actorUser.getFullName())
                        .avatarUrl(actorUser.getAvatarUrl())
                        .isPublic(actorUser.isPublic())
                        .isVerified(actorUser.isVerified())
                        .build();
            }
        }
        
        return NotificationResponse.builder()
                .id(notification.getId())
                .type(notification.getType())
                .content(notification.getContent())
                .actor(actor)
                .referenceId(notification.getReferenceId())
                .isRead(notification.isRead())
                .createdAt(notification.getCreatedAt())
                .build();
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/TokenService.java
================
package com.socialapp.Zircuit.service;
import com.socialapp.Zircuit.exception.BadRequestException;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.model.entity.VerificationToken;
import com.socialapp.Zircuit.repository.UserRepository;
import com.socialapp.Zircuit.repository.VerificationTokenRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class TokenService {
    private final VerificationTokenRepository tokenRepository;
    private final UserRepository userRepository;

    @Value("${app.token.verification.expiration-hours:24}")
    private long tokenExpirationHours;

    @Transactional
    public String createEmailVerificationToken(User user, String email) {
        // Delete any existing verification tokens for this user
        tokenRepository.deleteByUserIdAndTokenType(user.getId(), VerificationToken.TokenType.EMAIL_VERIFICATION);
        
        // Create a new token
        String tokenValue = UUID.randomUUID().toString();
        VerificationToken token = VerificationToken.builder()
                .token(tokenValue)
                .user(user)
                .email(email)
                .tokenType(VerificationToken.TokenType.EMAIL_VERIFICATION)
                .expiryDate(Instant.now().plus(tokenExpirationHours, ChronoUnit.HOURS))
                .used(false)
                .build();
        
        tokenRepository.save(token);
        return tokenValue;
    }

    @Transactional
    public boolean verifyEmail(String token) {
        VerificationToken verificationToken = tokenRepository.findByToken(token)
                .orElseThrow(() -> new BadRequestException("Invalid or expired verification token"));
        
        // Check if token is valid
        if (verificationToken.isExpired()) {
            throw new BadRequestException("Verification token has expired");
        }
        
        if (verificationToken.isUsed()) {
            throw new BadRequestException("Verification token has already been used");
        }
        
        if (verificationToken.getTokenType() != VerificationToken.TokenType.EMAIL_VERIFICATION) {
            throw new BadRequestException("Invalid token type");
        }
        
        // Mark token as used
        verificationToken.setUsed(true);
        tokenRepository.save(verificationToken);
        
        // Update user's verified status
        User user = verificationToken.getUser();
        
        // Make sure the email still matches (user hasn't changed email again)
        if (!user.getEmail().equals(verificationToken.getEmail())) {
            throw new BadRequestException("Email address has changed since this verification was requested");
        }
        
        user.setVerified(true);
        userRepository.save(user);
        
        return true;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/service/UserService.java
================
package com.socialapp.Zircuit.service;

import com.socialapp.Zircuit.exception.BadRequestException;
import com.socialapp.Zircuit.exception.ResourceNotFoundException;
import com.socialapp.Zircuit.exception.UnauthorizedException;
import com.socialapp.Zircuit.model.dto.request.ProfileUpdateRequest;
import com.socialapp.Zircuit.model.dto.request.SettingsUpdateRequest;
import com.socialapp.Zircuit.model.dto.response.ProfileResponse;
import com.socialapp.Zircuit.model.dto.response.UserSummaryResponse;
import com.socialapp.Zircuit.model.entity.User;
import com.socialapp.Zircuit.repository.FollowRepository;
import com.socialapp.Zircuit.repository.UserRepository;
import com.socialapp.Zircuit.security.JwtTokenProvider;
import com.socialapp.Zircuit.security.UserPrincipal;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
//import java.util.Objects;
import java.util.UUID;

@Service
@RequiredArgsConstructor
@Slf4j
public class UserService {
    private final UserRepository userRepository;
    private final FollowRepository followRepository;
    private final EmailService emailService;
    private final JwtTokenProvider tokenProvider; 

    @Value("${app.file.upload-dir}")
    private String uploadDir;

    @Transactional(readOnly = true)
    public ProfileResponse getUserProfile(String userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        
        // Get follower and following counts
        long followerCount = followRepository.countFollowersByUserId(userId);
        long followingCount = followRepository.countFollowingByUserId(userId);
        
        // Check if current user is following the requested user
        boolean isFollowing = false;
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.isAuthenticated() && 
                !authentication.getPrincipal().equals("anonymousUser")) {
            UserPrincipal currentUser = (UserPrincipal) authentication.getPrincipal();
            if (!currentUser.getId().equals(userId)) {
                isFollowing = followRepository.existsByIdFollowerIdAndIdFollowedId(currentUser.getId(), userId);
            }
        }
        
        return ProfileResponse.builder()
                .id(user.getId())
                .username(user.getUsername())
                .email(user.getEmail())
                .fullName(user.getFullName())
                .bio(user.getBio())
                .avatarUrl(user.getAvatarUrl())
                .websiteUrl(user.getWebsiteUrl())
                .location(user.getLocation())
                .isPublic(user.isPublic())
                .isVerified(user.isVerified())
                .followerCount(followerCount)
                .followingCount(followingCount)
                .isFollowing(isFollowing)
                .build();
    }
    
    @Transactional
    public ProfileResponse updateUserProfile(String userId, ProfileUpdateRequest request) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        
        // Check if username update is requested and valid
        if (request.getUsername() != null && !request.getUsername().equals(user.getUsername())) {
            // Check if username is taken
            if (userRepository.existsByUsername(request.getUsername())) {
                throw new BadRequestException("Username is already taken");
            }
            user.setUsername(request.getUsername());
        }
        
        // Update other fields if provided
        if (request.getFullName() != null) {
            user.setFullName(request.getFullName());
        }
        
        if (request.getBio() != null) {
            user.setBio(request.getBio());
        }
        
        if (request.getWebsiteUrl() != null) {
            user.setWebsiteUrl(request.getWebsiteUrl());
        }
        
        if (request.getLocation() != null) {
            user.setLocation(request.getLocation());
        }
        
        User updatedUser = userRepository.save(user);
        
        return getUserProfile(updatedUser.getId());
    }
    
    @Transactional
    public UserSummaryResponse updateUserSettings(String userId, SettingsUpdateRequest request) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        
        // Update visibility setting if provided
        if (request.getIsPublic() != null) {
            user.setPublic(request.getIsPublic());
        }
        
        // Update email if provided and valid
        if (request.getEmail() != null && !request.getEmail().equals(user.getEmail())) {
            // Check if email is already taken
            if (userRepository.existsByEmail(request.getEmail())) {
                throw new BadRequestException("Email is already registered");
            }
            
            // Update the email
            user.setEmail(request.getEmail());
            user.setVerified(false);
            
            // Save the user first to ensure it has an ID if it's a new user
            User updatedUser = userRepository.save(user);
            
            // Generate verification token and send email
            try {
                // Create a verification token
                String token = tokenProvider.generateEmailVerificationToken(updatedUser.getId());
                
                // Send verification email
                emailService.sendVerificationEmail(
                    request.getEmail(),
                    token,
                    updatedUser.getFullName() != null ? updatedUser.getFullName() : updatedUser.getUsername()
                );
                
                log.info("Verification email sent to: {}", request.getEmail());
                
                return UserSummaryResponse.builder()
                        .id(updatedUser.getId())
                        .username(updatedUser.getUsername())
                        .email(updatedUser.getEmail())
                        .fullName(updatedUser.getFullName())
                        .avatarUrl(updatedUser.getAvatarUrl())
                        .isPublic(updatedUser.isPublic())
                        .isVerified(updatedUser.isVerified())
                        .build();
            } catch (Exception e) {
                log.error("Failed to send verification email: {}", e.getMessage());
                throw new BadRequestException("Failed to send verification email. Please try again later.");
            }
        }
        
        User updatedUser = userRepository.save(user);
        
        return UserSummaryResponse.builder()
                .id(updatedUser.getId())
                .username(updatedUser.getUsername())
                .email(updatedUser.getEmail())
                .fullName(updatedUser.getFullName())
                .avatarUrl(updatedUser.getAvatarUrl())
                .isPublic(updatedUser.isPublic())
                .isVerified(updatedUser.isVerified())
                .build();
    }
    
    @Transactional
    public String uploadAvatar(String userId, MultipartFile file) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        
        // Validate file
        if (file.isEmpty()) {
            throw new BadRequestException("File cannot be empty");
        }
        
        // Check file size (max 5MB)
        if (file.getSize() > 5 * 1024 * 1024) {
            throw new BadRequestException("File size exceeds maximum limit (5MB)");
        }
        
        // Check file type (only images)
        String contentType = file.getContentType();
        if (contentType == null || (!contentType.startsWith("image/"))) {
            throw new BadRequestException("Only image files are allowed");
        }
        
        try {
            // Create upload directory if it doesn't exist
            Path uploadPath = Paths.get(uploadDir);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
            }
            
            // Generate a unique filename
            String originalFilename = file.getOriginalFilename();
            String extension = originalFilename != null ? 
                    originalFilename.substring(originalFilename.lastIndexOf(".")) : ".jpg";
            String filename = UUID.randomUUID() + extension;
            
            // Save the file
            Path targetLocation = uploadPath.resolve(filename);
            Files.copy(file.getInputStream(), targetLocation, StandardCopyOption.REPLACE_EXISTING);
            
            // Update user's avatar URL
            String avatarUrl = "/uploads/" + filename;
            user.setAvatarUrl(avatarUrl);
            userRepository.save(user);
            
            return avatarUrl;
        } catch (IOException ex) {
            throw new BadRequestException("Could not upload file: " + ex.getMessage());
        }
    }
    
    @Transactional
public boolean verifyEmail(String token) {
    try {
        if (!tokenProvider.validateToken(token)) {
            return false;
        }
        
        String userId = tokenProvider.getUserIdFromToken(token);
        User user = userRepository.findById(userId)
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userId));
        
        if (user.isVerified()) {
            return true; // Already verified
        }
        
        user.setVerified(true);
        userRepository.save(user);
        
        return true;
    } catch (Exception e) {
        log.error("Error verifying email", e);
        return false;
    }
}
    
    public User getCurrentUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null || !authentication.isAuthenticated() || 
                authentication.getPrincipal().equals("anonymousUser")) {
            throw new UnauthorizedException("Not authenticated");
        }
        
        UserPrincipal userPrincipal = (UserPrincipal) authentication.getPrincipal();
        return userRepository.findById(userPrincipal.getId())
                .orElseThrow(() -> new ResourceNotFoundException("User", "id", userPrincipal.getId()));
    }
}

================
File: src/main/java/com/socialapp/Zircuit/ZircuitApplication.java
================
package com.socialapp.Zircuit;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.boot.autoconfigure.domain.EntityScan;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

//import jakarta.persistence.Entity;

import org.springframework.cache.annotation.EnableCaching;

@SpringBootApplication
@EnableAsync
@EnableScheduling
@EnableCaching
@EnableConfigurationProperties // Remove if not needed
@EntityScan(basePackages = "com.socialapp.Zircuit.model.entity") // Adjust the package name as needed

	// This annotation is used to specify the base packages to scan for JPA entities.
	// It is useful when your entity classes are in a different package than the main application class.

	// The @EnableConfigurationProperties annotation is used to enable support for @ConfigurationProperties
	// annotated beans. It allows you to bind external configuration properties to Java objects.

	// The @EnableAsync annotation is used to enable Spring's asynchronous method execution capability.
	// It allows you to run methods asynchronously in a separate thread.

	// The @EnableScheduling annotation is used to enable Spring's scheduled task execution capability.
	// It allows you to schedule tasks to be executed at fixed intervals or at specific times.
	
public class ZircuitApplication {
	public static void main(String[] args) {
		SpringApplication.run(ZircuitApplication.class, args);
	}

}

================
File: src/main/resources/META-INF/additional-spring-configuration-metadata.json
================
{"properties": [
  {
    "name": "app.jwt.secret",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.secret'"
  },
  {
    "name": "app.jwt.expiration",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.expiration'"
  },
  {
    "name": "app.jwt.prefix",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.prefix'"
  },
  {
    "name": "app.jwt.header",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.header'"
  },
  {
    "name": "app.jwt.refresh-expiration",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.refresh-expiration'"
  },
  {
    "name": "file.upload-dir",
    "type": "java.lang.String",
    "description": "A description for 'file.upload-dir'"
  },
  {
    "name": "app.frontend.url",
    "type": "java.lang.String",
    "description": "A description for 'app.frontend.url'"
  },
  {
    "name": "spring.datasource.hikkari.ConnectionTimeout",
    "type": "java.lang.String",
    "description": "A description for 'spring.datasource.hikkari.ConnectionTimeout'"
  },
  {
    "name": "management.endpoints.web.exposure.include",
    "type": "java.lang.String",
    "description": "A description for 'management.endpoints.web.exposure.include'"
  },
  {
    "name": "management.endpoint.health.show-details",
    "type": "java.lang.String",
    "description": "A description for 'management.endpoint.health.show-details'"
  },
  {
    "name": "spring.datasource.hikkari.ConnectionTimeout",
    "type": "java.lang.String",
    "description": "A description for 'spring.datasource.hikkari.ConnectionTimeout'"
  },
  {
    "name": "app.verification.tokenExpirationMs",
    "type": "java.lang.String",
    "description": "A description for 'app.verification.tokenExpirationMs'"
  },
  {
    "name": "app.verification.email.sender",
    "type": "java.lang.String",
    "description": "A description for 'app.verification.email.sender'"
  },
  {
    "name": "app.password-reset.tokenExpirationMs",
    "type": "java.lang.String",
    "description": "A description for 'app.password-reset.tokenExpirationMs'"
  },
  {
    "name": "app.jwt.refreshExpirationMs",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.refreshExpirationMs'"
  },
  {
    "name": "app.jwt.refreshExpirationMs",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.refreshExpirationMs'"
  },
  {
    "name": "app.jwt.expirationMs",
    "type": "java.lang.String",
    "description": "A description for 'app.jwt.expirationMs'"
  },
  {
    "name": "app.oauth2.redirectUri",
    "type": "java.lang.String",
    "description": "A description for 'app.oauth2.redirectUri'"
  },
  {
    "name": "app.file.upload-dir",
    "type": "java.lang.String",
    "description": "A description for 'app.file.upload-dir'"
  }
]}

================
File: src/test/java/com/socialapp/Zircuit/ZircuitApplicationTests.java
================
package com.socialapp.Zircuit;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

@SpringBootTest
@ActiveProfiles("test")
class ZircuitApplicationTests {

	@Test
	void contextLoads() {
	}

}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/Follow.java
================
package com.socialapp.Zircuit.model.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "follows")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Follow {
    @EmbeddedId
    private FollowId id;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "follower_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User follower;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "followed_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User followed;

    @Embeddable
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class FollowId implements java.io.Serializable {
        
        @Column(name = "follower_id", length = 36)
        private String followerId;
        
        @Column(name = "followed_id", length = 36)
        private String followedId;
    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/Message.java
================
package com.socialapp.Zircuit.model.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "messages")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Message {
    @Id
    @Column(name = "message_id", length = 36)
    private String id;

    @Column(name = "sender_id", length = 36, nullable = false)
    private String senderId;

    @Column(name = "receiver_id", length = 36, nullable = false)
    private String receiverId;

    @Column(name = "content", columnDefinition = "TEXT", nullable = false)
    private String content;

    @Column(name = "is_read", nullable = false)
    private boolean isRead = false;

    @Column(name = "is_deleted_by_sender", nullable = false)
    private boolean isDeletedBySender = false;

    @Column(name = "is_deleted_by_receiver", nullable = false)
    private boolean isDeletedByReceiver = false;

    @CreationTimestamp
    @Column(name = "sent_at", nullable = false, updatable = false)
    private LocalDateTime sentAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "sender_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User sender;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "receiver_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User receiver;

    @PrePersist
    public void prePersist() {
        if (id == null) {
            id = java.util.UUID.randomUUID().toString();
        }
    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/Notification.java
================
package com.socialapp.Zircuit.model.entity;

import com.socialapp.Zircuit.model.enums.NotificationType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "notifications")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Notification {
    @Id
    @Column(name = "notification_id", length = 36)
    private String id;

    @Column(name = "user_id", length = 36, nullable = false)
    private String userId;

    @Enumerated(EnumType.STRING)
    @Column(name = "type", nullable = false)
    private NotificationType type;

    @Column(name = "reference_id", length = 36)
    private String referenceId;

    @Column(name = "actor_id", length = 36)
    private String actorId;

    @Column(name = "content", columnDefinition = "TEXT", nullable = false)
    private String content;

    @Column(name = "is_read", nullable = false)
    private boolean isRead = false;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User user;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "actor_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User actor;

    @PrePersist
    public void prePersist() {
        if (id == null) {
            id = java.util.UUID.randomUUID().toString();
        }
    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/User.java
================
package com.socialapp.Zircuit.model.entity;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.UpdateTimestamp;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "users")
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class User {
    @Id
    @Column(name = "userID", nullable = false, unique = true, length = 36)
    private String id;

    @Column(name = "username", length = 50, nullable = false, unique = true)
    private String username;

    @Column(name = "email", length = 255, nullable = false, unique = true)
    private String email;

    @Column(name = "password_hash", length = 255)
    private String passwordHash;

    @Column(name = "full_name", length = 100)
    private String fullName;

    @Column(name = "bio", columnDefinition = "TEXT")
    private String bio;

    @Column(name = "avatar_url", length = 255)
    private String avatarUrl;

    @Column(name = "website_url", length = 255)
    private String websiteUrl;

    @Column(name = "location", length = 100)
    private String location;

    @Column(name = "is_public", nullable = false)
    private boolean isPublic = false;

    @Column(name = "is_active", nullable = false)
    private boolean isActive = true;

    @Column(name = "is_verified", nullable = false)
    private boolean isVerified = false;

    @Column(name = "last_login_at")
    private LocalDateTime lastLoginAt;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @PrePersist
    public void prePersist() {
        if (this.id == null) {
            this.id = java.util.UUID.randomUUID().toString();
        }

    }
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/UserAuth.java
================
package com.socialapp.Zircuit.model.entity;

import com.socialapp.Zircuit.model.enums.AuthProvider;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "user_auth")
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class UserAuth {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "auth_id")
    private Long id;

    @Column(name = "userID", length = 36, nullable = false)
    private String userId;

    @Enumerated(EnumType.STRING)
    @Column(name = "provider", nullable = false)
    private AuthProvider provider;

    @Column(name = "provider_user_id", nullable = false)
    private String providerUserId;

    @Column(name = "access_token_hash")
    private String accessTokenHash;

    @Column(name = "refresh_token_hash")
    private String refreshTokenHash;

    @Column(name = "expiry_time")
    private LocalDateTime expiryTime;

    @CreationTimestamp
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "userID", referencedColumnName = "userID", insertable = false, updatable = false)
    private User user;
}

================
File: src/main/java/com/socialapp/Zircuit/model/entity/UserSettings.java
================
package com.socialapp.Zircuit.model.entity;

import com.socialapp.Zircuit.model.enums.MessagePermission;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import jakarta.persistence.*;

@Entity
@Table(name = "user_settings")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserSettings {
    @Id
    @Column(name = "user_id", length = 36)
    private String userId;

    @Enumerated(EnumType.STRING)
    @Column(name = "allow_messages_from", nullable = false)
    private MessagePermission allowMessagesFrom = MessagePermission.ALL;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", referencedColumnName = "userID", insertable = false, updatable = false)
    private User user;
}



================================================================
End of Codebase
================================================================
